{"packages":[{"organization":"ballerinax", "name":"jaeger", "version":"0.2.3", "platform":"java11", "languageSpecificationVersion":"2021R1", "URL":"/ballerinax/jaeger/0.2.3", "balaVersion":"2.0.0", "balaURL":"https://fileserver.central.ballerina.io/2.0/ballerinax/jaeger/0.2.3/ballerinax-jaeger-java11-0.2.3.bala", "digest":"sha-256=06542eeebba0b7e87d6c9ddaf5a49d890ec3c4d52a6cd01c52d27a487b3109b3", "summary":"", "readme":"## Package Overview\n\nThe Jaeger Observability Extension is one of the tracing extensions of the<a target=\"_blank\" href=\"https:\/\/ballerina.io\/\"> Ballerina<\/a> language.\n\nIt provides an implementation for tracing and publishing traces to a Jaeger Agent.\n\n## Enabling Jaeger Extension\n\nTo package the Jaeger extension into the Jar, follow the following steps.\n1. Add the following import to your program.\n```ballerina\nimport ballerinax\/jaeger as _;\n```\n\n2. Add the following to the `Ballerina.toml` when building your program.\n```toml\n[package]\norg = \"my_org\"\nname = \"my_package\"\nversion = \"1.0.0\"\n\n[build-options]\nobservabilityIncluded=true\n```\n\nTo enable the extension and publish traces to Jaeger, add the following to the `Config.toml` when running your program.\n```toml\n[ballerina.observe]\ntracingEnabled=true\ntracingProvider=\"jaeger\"\n\n[ballerinax.jaeger]\nagentHostname=\"127.0.0.1\"  # Optional Configuration. Default value is localhost\nagentPort=55680             # Optional Configuration. Default value is 55680\n```", "template":false, "licenses":[], "authors":[], "sourceCodeLocation":"", "keywords":[], "ballerinaVersion":"slbeta1", "icon":"", "createdDate":1622737487000, "modules":[{"name":"jaeger", "summary":"", "readme":"", "apiDocURL":"https://docs.central.ballerina.io/ballerinax/jaeger/0.2.3", "packageUrl":"/ballerinax/jaeger/0.2.3"}], "pullCount":3}, {"organization":"ballerinax", "name":"choreo", "version":"0.2.7", "platform":"java11", "languageSpecificationVersion":"2021R1", "URL":"/ballerinax/choreo/0.2.7", "balaVersion":"2.0.0", "balaURL":"https://fileserver.central.ballerina.io/2.0/ballerinax/choreo/0.2.7/ballerinax-choreo-java11-0.2.7.bala", "digest":"sha-256=e8bf2467d7198ca7c4aa004cef437041ac0cebe7d8d9f527f65c80e00c94b9d0", "summary":"", "readme":"## Package Overview\n\nThe Choreo Observability Extension is one of the observability extensions of the [Ballerina](https:\/\/ballerina.io\/) language.\n\nIt provides an implementation for publishing traces & metrics to Choreo.\n\n## Enabling Choreo Extension\n\nTo package the Choreo extension into the Jar, follow the following steps.\n1. Add the following import to your program.\n```ballerina\nimport ballerinax\/choreo as _;\n```\n\n2. Add the following to the `Ballerina.toml` when building your program.\n```toml\n[package]\norg = \"my_org\"\nname = \"my_package\"\nversion = \"1.0.0\"\n\n[build-options]\nobservabilityIncluded=true\n```\n\nTo enable the extension and connect to Choreo, add the following to the `Config.toml` when running your program.\n```toml\n[ballerina.observe]\nenabled=true\nprovider=\"choreo\"\n```", "template":false, "licenses":[], "authors":[], "sourceCodeLocation":"", "keywords":[], "ballerinaVersion":"slbeta1", "icon":"", "createdDate":1622737198000, "modules":[{"name":"choreo", "summary":"", "readme":"", "apiDocURL":"https://docs.central.ballerina.io/ballerinax/choreo/0.2.7", "packageUrl":"/ballerinax/choreo/0.2.7"}], "pullCount":2}, {"organization":"ballerina", "name":"websub", "version":"1.2.0-beta.1", "platform":"java11", "languageSpecificationVersion":"2021R1", "URL":"/ballerina/websub/1.2.0-beta.1", "balaVersion":"2.0.0", "balaURL":"https://fileserver.central.ballerina.io/2.0/ballerina/websub/1.2.0-beta.1/ballerina-websub-java11-1.2.0-beta.1.bala", "digest":"sha-256=82e9ca870f793b0ec18cd62eed5b460f0bbebcd77ebd6473cef500f82df8b5de", "summary":"", "readme":"## Package Overview\n\nThe `websub` package is one of the standard library packages of the <a target=\"_blank\" href=\"https:\/\/ballerina.io\/\">Ballerina<\/a> language.\n\nThis package provides the capability to easily implement a WebSub compliant **Subscriber Service**.\n\n## Report Issues\n\nTo report bugs, request new features, start new discussions, view project boards, etc., go to the [Ballerina Standard Library parent repository](https:\/\/github.com\/ballerina-platform\/ballerina-standard-library).\n\n## Useful Links\n\n* Discuss code changes of the Ballerina project in [ballerina-dev@googlegroups.com](mailto:ballerina-dev@googlegroups.com).\n* Chat live with us via our [Slack channel](https:\/\/ballerina.io\/community\/slack\/).\n* Post all technical questions on Stack Overflow with the [#ballerina](https:\/\/stackoverflow.com\/questions\/tagged\/ballerina) tag.", "template":false, "licenses":[], "authors":[], "sourceCodeLocation":"", "keywords":[], "ballerinaVersion":"slbeta1", "icon":"", "createdDate":1622726160000, "modules":[{"name":"websub", "summary":"", "readme":"## Overview\n\nThis module provides APIs for WebSub Subscriber Service.\n\n[**WebSub**](https:\/\/www.w3.org\/TR\/websub\/) is a common mechanism for communication between publishers of any kind of Web content and their subscribers, based on HTTP webhooks. Subscription requests are relayed through hubs, which validate and verify the request. Hubs then distribute new and updated content to subscribers when it becomes available. WebSub was previously known as PubSubHubbub.\n\n[**WebSub Subscriber**](https:\/\/www.w3.org\/TR\/websub\/#subscriber) is an implementation that discovers the `hub` and `topic URL` of a given `resource URL`, subscribes to updates at the hub, and accepts content distribution requests from the `hub`.\n\n### Basic flow with WebSub\n\n1. The subscriber discovers (from the publisher) the topic it needs to subscribe to and the hub(s) that deliver notifications on the updates of the topic.\n\n2. The subscriber sends a subscription request to one or more discovered hub(s) specifying the discovered topic along \n with the other subscription parameters such as:\n    - The callback URL to which the content is expected to be delivered.\n    - (Optional) The lease period (in seconds) the subscriber wants the subscription to stay active.\n    - (Optional) A secret to use for the [authenticated content distribution](https:\/\/www.w3.org\/TR\/websub\/#signing-content).\n  \n3. The hub sends an intent verification request to the specified callback URL. If the response indicates \nthe verification\n (by echoing a challenge specified in the request) by the subscriber, the subscription is added for the topic at the \n hub.\n   \n4. The publisher notifies the hub of the updates to the topic and the content to deliver is identified.\n\n5. The hub delivers the identified content to the subscribers of the topic.\n\n#### Subscribing\n\n* The WebSub Subscriber provides the mechanism to subscribe in a `hub` to a given `topic URL`. \n```ballerina\n@websub:SubscriberServiceConfig {\n    target: [\"<HUB_URL>\", \"<TOPIC_URL>\"], \n    leaseSeconds: 36000\n} \nservice \/subscriber on new websub:Listener(9090) {\n    remote function onSubscriptionValidationDenied(websub:SubscriptionDeniedError msg) returns websub:Acknowledgement? {\n        \/\/ implement subscription validation denied logic here\n        return websub:ACKNOWLEDGEMENT;\n    }\n\n    remote function onSubscriptionVerification(websub:SubscriptionVerification msg)\n                        returns websub:SubscriptionVerificationSuccess|websub:SubscriptionVerificationError {\n        \/\/ implement subscription intent verification logic here\n        return websub:SUBSCRIPTION_VERIFICATION_SUCCESS;\n    }\n\n    remote function onEventNotification(websub:ContentDistributionMessage event) \n                        returns websub:Acknowledgement|websub:SubscriptionDeletedError? {\n        \/\/ implement on event notification logic here\n        return websub:ACKNOWLEDGEMENT;\n    }\n}\n```\n\n#### Resource Discovery\n\n* The WebSub Subscriber also provides the mechanism to discover the `hub` and `topic URL` resources dynamically via the provided `resource URL` and initiates the subscription.\n```ballerina\n@websub:SubscriberServiceConfig {\n    target: \"RESOURCE_URL\", \n    leaseSeconds: 36000\n} \nservice \/subscriber on new websub:Listener(9090) {\n    remote function onEventNotification(websub:ContentDistributionMessage event) \n                        returns websub:Acknowledgement|websub:SubscriptionDeletedError? {\n        \/\/ implement on event notification logic here\n        return websub:ACKNOWLEDGEMENT;\n    }\n\n    \/\/ other remote methods are optional to be implemented\n}\n```\n\n#### Dynamic URI Generation\n\n* The service path for a WebSub Subscriber is optional. The WebSub Subscriber service has the capability to generate the service path dynamically.\n```ballerina\n@websub:SubscriberServiceConfig {\n    target: \"RESOURCE_URL\", \n    leaseSeconds: 36000\n} \nservice on new websub:Listener(9090) {\n    remote function onEventNotification(websub:ContentDistributionMessage event) \n                        returns websub:Acknowledgement|websub:SubscriptionDeletedError? {\n        \/\/ implement on event notification logic here\n        return websub:ACKNOWLEDGEMENT;\n    }\n\n    \/\/ other remote methods are optional to be implemented\n}\n```\n\n#### Running Subscriber Service Locally\n\n* [**nGrok**](https:\/\/ngrok.com\/) is a TCP Tunneling software, which is used to expose services running locally in the public network.\n* If you want to run the subscriber service in your local machine, you could use **nGrok** to expose it to the public network.\n* First, [download and install](https:\/\/ngrok.com\/download) **nGrok**.\n* Run the following command to expose the local port `9090` to the public network via `HTTPS`. For information, see the [ngrok documentation](https:\/\/ngrok.com\/docs#http-bind-tls)).\n```bash\nngrok http -bind-tls=true 9090\n```\n* Extract the public URL provided by **nGrok** and provide it as the callback URL for the subscriber service.\n```ballerina\n@websub:SubscriberServiceConfig {\n    target: \"RESOURCE_URL\", \n    leaseSeconds: 36000,\n    callback: \"<NGROK_PUBLIC_URL>\",\n    appendServiceUrl: true\n} \nservice on new websub:Listener(9090) {\n    remote function onEventNotification(websub:ContentDistributionMessage event) \n                        returns websub:Acknowledgement|websub:SubscriptionDeletedError? {\n        \/\/ implement on event notification logic here\n        return websub:ACKNOWLEDGEMENT;\n    }\n\n    \/\/ other remote methods are optional to be implemented\n}\n```\n\n# Returning Errors from Remote Methods\n\n* Remote functions in `websub:SubscriberService` can return `error` type.\n```ballerina\n@websub:SubscriberServiceConfig {\n    target: \"RESOURCE_URL\", \n    leaseSeconds: 36000,\n    callback: \"<NGROK_PUBLIC_URL>\",\n    appendServiceUrl: true\n} \nservice on new websub:Listener(9090) {\n    remote function onEventNotification(websub:ContentDistributionMessage event) \n                        returns websub:Acknowledgement|websub:SubscriptionDeletedError|error? {\n        boolean isValidRequest = check validateRequest(event);\n        if isValidRequest {\n            \/\/ implement on event notification logic here\n            return websub:ACKNOWLEDGEMENT;\n        }\n    \n    }\n\n    \/\/ other remote methods are optional to be implemented\n}\n\nfunction validateRequest(websub:ContentDistributionMessage event) returns boolean|error {\n    \/\/ validation logic \n}\n```\n\n* For each remote method `error` return has a different meaning. Following table depicts the meaning inferred from `error` returned from all available remote methods.\n\n| Method        | Interpreted meaning for Error Return |\n| ----------- | ---------------- |\n| onSubscriptionValidationDenied | Successfull acknowledgement|\n| onSubscriptionVerification | Subscription verification failure|\n| onEventNotification | Successfull acknowledgement|", "apiDocURL":"https://docs.central.ballerina.io/ballerina/websub/1.2.0-beta.1", "packageUrl":"/ballerina/websub/1.2.0-beta.1"}], "pullCount":1}, {"organization":"ballerina", "name":"openapi", "version":"0.9.0-beta.1", "platform":"java11", "languageSpecificationVersion":"2021R1", "URL":"/ballerina/openapi/0.9.0-beta.1", "balaVersion":"2.0.0", "balaURL":"https://fileserver.central.ballerina.io/2.0/ballerina/openapi/0.9.0-beta.1/ballerina-openapi-java11-0.9.0-beta.1.bala", "digest":"sha-256=831a59e0e36fac500564a35f7db98876e5982b51fde62df7bd76970b00197949", "summary":"", "readme":"## Package Overview\n\nThe `openapi` package is one of the command-line tools of the [Ballerina](https:\/\/ballerina.io\/) language.\n\nThis package provides support for the Ballerina OpenAPI tooling. The OpenAPI commands will make it easy to \nstart the development of a service documented in an OpenAPI contract in Ballerina by generating the Ballerina service \nand client skeletons and exporting the OpenAPI definition of a Ballerina service. The OpenAPI compiler plugin will \nallow you to validate a service implementation against an OpenAPI contract during the compile time. This plugin  \nensures that the implementation of a service does not deviate from its OpenAPI contract.\n\n### Report Issues\nTo report bugs, request new features, start new discussions, etc., go to the [open issues](https:\/\/github.com\/ballerina-platform\/ballerina-openapi\/issues)\n\n### Useful Links\n\n* Discuss about code changes of the Ballerina project in [ballerina-dev@googlegroups.com](mailto:ballerina-dev@googlegroups.com).\n* Chat live with us via our [Slack channel](https:\/\/ballerina.io\/community\/slack\/).\n* Post all technical questions on Stack Overflow with the [#ballerina](https:\/\/stackoverflow.com\/questions\/tagged\/ballerina) tag.\n* View the [Ballerina performance test results](performance\/benchmarks\/summary.md).", "template":false, "licenses":[], "authors":[], "sourceCodeLocation":"", "keywords":[], "ballerinaVersion":"slbeta1", "icon":"", "createdDate":1622707532000, "modules":[{"name":"openapi", "summary":"", "readme":"## Module Overview\n\nThis module provides the Ballerina OpenAPI tooling, which will make it easy to start the development of a service documented in an OpenAPI contract in Ballerina by generating the Ballerina service and client skeletons.\n\nThe OpenAPI tools provide the following capabilities. \n\n 1. Generate the Ballerina service or client code for a given OpenAPI definition. \n 2. Export the OpenAPI definition of a Ballerina service.\n 3. Validate the service implementation of a given OpenAPI contract.\n    \nThe `openapi` command in Ballerina is used for OpenAPI to Ballerina and Ballerina to OpenAPI code generations. \nCode generation from OpenAPI to Ballerina can produce `ballerina service stubs` and `ballerina client stubs`.\nThe OpenAPI compiler plugin will allow you to validate a service implementation against an OpenAPI contract during\n the compile time.\nThis plugin ensures that the implementation of a service does not deviate from its OpenAPI contract.   \n\n### OpenAPI to Ballerina\n#### Generate Service and Client Stub from an OpenAPI Contract\n\n```bash\nbal openapi -i <openapi-contract-path> \n               [--tags: tags list]\n               [--operations: operationsID list]\n               [--mode service|client ]\n               [(-o|--output): output file path]\n```\nGenerates both the Ballerina service and Ballerina client stubs for a given OpenAPI file.\n\nThis `-i <openapi-contract-path>` parameter of the command is mandatory. It will get the path to the\n OpenAPI contract file (i.e., `my-api.yaml` or `my-api.json`) as an input.\n\nYou can give the specific tags and operations that you need to document as services without documenting all the operations using these optional `--tags` and `--operations` commands.\n\nThe `(-o|--output)` is an optional parameter. You can use this to give the output path of the generated files.\nIf not, it will take the execution path as the output path.\n\n##### Modes\nIf you want to generate a service only, you can set the mode as `service` in the OpenAPI tool.\n\n```bash\n    bal openapi -i <openapi-contract-path> --mode service [(-o|--output) output file path]\n```\n\nIf you want to generate a client only, you can set the mode as  `client` in the OpenAPI tool. \nThis client can be used in client applications to call the service defined in the OpenAPI file.\n\n```bash\n    bal openapi -i <openapi-contract-path> --mode client [(-o|--output) output file path]\n```\n\n### Ballerina to OpenAPI\n#### Service to OpenAPI Export\n```bash\n    bal openapi -i <ballerina-file-path> \n               [(-o|--output) output openapi file path]\n```\nExport the Ballerina service to an  OpenAPI Specification 3.0 definition. For the export to work properly, \nthe input Ballerina service should be defined using the basic service and resource-level HTTP annotations.\nIf you need to document an OpenAPI contract for only one given service, then use this command.\n```bash\n    bal openapi -i <ballerina-file-path> (-s | --service) <service-name>\n```\n\n### Samples for OpenAPI Commands\n#### Generate Service and Client Stub from OpenAPI\n```bash\n    bal openapi -i hello.yaml\n```\n\nThis will generate a Ballerina service and client stub for the `hello.yaml` OpenAPI contract named `hello-service\n` and client named `hello-client`. The above command can be run from within anywhere on the execution path. \nIt is not mandatory to run it from inside the Ballerina project.\n\nOutput:\n```bash\nThe service generation process is complete. The following files were created.\n-- hello-service.bal\n-- client.bal\n-- types.bal\n```\n#### Generate an OpenAPI Contract from a Service\n\n ```bash\n    bal openapi -i modules\/helloworld\/helloService.bal\n  ```\nThis will generate the OpenAPI contracts for the Ballerina services, which are in the `hello.bal` Ballerina file.\n ```bash \n    bal openapi -i modules\/helloworld\/helloService.bal (-s | --service) helloworld\n  ```\nThis command will generate the `helloworld-openapi.yaml` file that is related to the `helloworld` service inside the\n `helloService.bal` file.\n ```bash\n    bal openapi -i modules\/helloworld\/helloService.bal --json\n  ```\nThis `--json` option can be used with the Ballerina to OpenAPI command to generate the `helloworld-openapi.json` file \ninstead of generating the YAML file.\n\n## OpenAPI Validator Compiler Plugin\n\nThe OpenAPI Validator Compiler plugin validates a service against a given OpenAPI contract. \nThe Compiler Plugin is activated if a service has the `openapi:ServiceInfo` annotation. This plugin compares \nthe service and the OpenAPI Contract and validates both against a pre-defined set of validation rules. \nIf any of the rules fail, the plugin will give the result as one or more compilation errors.\n\n### Annotation for Validator Plugin \nThe `@openapi:ServiceInfo` annotation is used to bind the service with an OpenAPI contract. You need to add \nthis annotation to the service file with the required values for enabling the validations.  \nThe following is an example of the annotation usage.\n```ballerina\n@openapi:ServiceInfo{\n    contract: “\/path\/to\/openapi.json|yaml”,\n    [ tag : “store” ],\n    [ operations: [“op1”, “op2”] ] \n    [ failOnErrors]: true\/false → default : true\n    [ excludeTags ]: [“pets”, “user”]\n    [ excludeOperations: [“op1”, “op2”] ]\n   }\nservice greet on new http:Listener(9090) {\n    ...\n}\n```\n#### Annotation Support for the Following Attributes:\n- **Contract** (Required) : **string**  :\nHere, you can provide a path to the OpenAPI contract as a string and the OpenAPI file can either be `.yaml` or `.json`\nThis is a required attribute.\n\n- **Tag** (Optional) : **string[]?**     :\nThe compiler will only validate resources against operations, which are tagged with a tag specified in the list.\nIf not specified, the compiler will validate resources against all the operations defined in the OpenAPI contract. \n\n- **Operations** (Optional): **string[]?**  :\nShould contain a list of operation names that need to be validated against the resources in the service.\nIf not specified, the compiler will validate resources against all the operations defined in the OpenAPI contract. If both tags and operations are defined, it will validate against the union set of the resources.\n\n- **ExcludeTags** (Optional) : **string[]?**    :\nThis feature is for users to store the tag. It does not need to be validated.\nAt the same time, the `excludeTag` and `Tag` cannot store and the plugin will generate warning messages regarding\n it.\n\n- **ExcludeOperations** (Optional) : **string[]?**  :\nThis feature is for users to store the operations that do not need to be validated.\nAt the same time, the `excludeOperations` and  `Operations` can not store and they will generate warning messages.\nThe `Tag` feature can store with `excludeOperations`. Then, all the tag operations will be validated except the `exclude`\n operations.\n \n- **FailOnErrors** (Optional) : **boolean value**   :\nIf you need to turn off the validation, add this to the annotation with the value as `false`.", "apiDocURL":"https://docs.central.ballerina.io/ballerina/openapi/0.9.0-beta.1", "packageUrl":"/ballerina/openapi/0.9.0-beta.1"}], "pullCount":439}, {"organization":"hevayo", "name":"beta1", "version":"0.2.0", "platform":"java11", "languageSpecificationVersion":"2021R1", "URL":"/hevayo/beta1/0.2.0", "balaVersion":"2.0.0", "balaURL":"https://fileserver.central.ballerina.io/2.0/hevayo/beta1/0.2.0/hevayo-beta1-java11-0.2.0.bala", "digest":"sha-256=aa675f3421d7f9ba9b657d52025163c92e62237dcb248dde93532c9fe29c082a", "summary":"Prints \"Hello World!\" with a hello function.", "readme":"Prints \"Hello World!\" with a hello function.\n\n# Package Overview\nPrints \"Hello World!\" as the output to the command line using a hello function.", "template":false, "licenses":[], "authors":[], "sourceCodeLocation":"", "keywords":[], "ballerinaVersion":"slbeta1", "icon":"", "createdDate":1622654158000, "modules":[{"name":"beta1", "summary":"", "readme":"", "apiDocURL":"https://docs.central.ballerina.io/hevayo/beta1/0.2.0", "packageUrl":"/hevayo/beta1/0.2.0"}], "pullCount":4}, {"organization":"ballerinax", "name":"java.jdbc", "version":"0.6.0-beta.1", "platform":"java11", "languageSpecificationVersion":"2021R1", "URL":"/ballerinax/java.jdbc/0.6.0-beta.1", "balaVersion":"2.0.0", "balaURL":"https://fileserver.central.ballerina.io/2.0/ballerinax/java.jdbc/0.6.0-beta.1/ballerinax-java.jdbc-java11-0.6.0-beta.1.bala", "digest":"sha-256=0c8349c0a285a79e1f02ca62171189a31f05b4fb89cd9226be1a77252917d871", "summary":"", "readme":"## Package Overview\n\nThe `jdbc` library is one of the external library packages of the<a target=\"_blank\" href=\"https:\/\/ballerina.io\/\"> Ballerina<\/a> language. This external package is maintained by the Ballerina team.\n\nIt provides the functionality required to access and manipulate data stored in any type of relational database\nthat is accessible via Java Database Connectivity (JDBC).\n\n### Report Issues\n\nTo report bugs, request new features, start new discussions, view project boards, etc., go to the [Ballerina Standard Library parent repository](https:\/\/github.com\/ballerina-platform\/ballerina-standard-library).\n\n### Useful Links\n- Discuss code changes of the Ballerina project in ballerina-dev@googlegroups.com.\n- Chat live with us via our [Slack channel](https:\/\/ballerina.io\/community\/slack\/).\n- Post all technical questions on Stack Overflow with the [#ballerina](https:\/\/stackoverflow.com\/questions\/tagged\/ballerina) tag", "template":false, "licenses":[], "authors":[], "sourceCodeLocation":"", "keywords":[], "ballerinaVersion":"slbeta1", "icon":"", "createdDate":1622649980000, "modules":[{"name":"java.jdbc", "summary":"", "readme":"## Overview\n\nThis module provides the functionality that is required to access and manipulate data stored in any type of relational database,\nwhich is accessible via Java Database Connectivity (JDBC).\n\n**Prerequisite:** Add the JDBC driver corresponding to the database you are trying to interact with\nas a native library dependency in your Ballerina project. Then, once you build the project by executing the `ballerina build`\ncommand, you should be able to run the resultant by executing the `ballerina run` command.\n\nE.g., The `Ballerina.toml` content for an H2 database will be as follows.\nChange the path to the JDBC driver appropriately.\n\n```toml\n[package]\norg = \"sample\"\nname = \"jdbc\"\nversion= \"0.1.0\"\n\n[[platform.java11.dependency]]\nartifactId = \"h2\"\nversion = \"1.4.200\"\npath = \"\/path\/to\/com.h2database.h2-1.4.200.jar\"\ngroupId = \"com.h2database\"\n``` \n\n### Client\nTo access a database, you must first create a\n[jdbc:Client](https:\/\/docs.central.ballerina.io\/ballerinax\/java.jdbc\/latest\/clients\/Client) object.\nThe examples for creating a JDBC client can be found below.\n\n#### Creating a Client\nThis example shows the different ways of creating the `jdbc:Client`. The client can be created by passing\nthe JDBC URL, which is a mandatory property and all other fields are optional.\n\nThe `dbClient` receives only the database URL.\n\nE.g., The DB client creation for an H2 database will be as follows.\n```ballerina\njdbc:Client|sql:Error dbClient = new (\"jdbc:h2:~\/path\/to\/database\");\n```\n\nThe `dbClient` receives the username and password in addition to the URL.\nIf the properties are passed in the same order as they are defined in the `jdbc:Client`, you can pass them\nwithout named params.\n\nE.g., The DB client creation for an H2 database will be as follows.\n```ballerina\njdbc:Client|sql:Error dbClient = new (\"jdbc:h2:~\/path\/to\/database\", \n                            \"root\", \"root\");\n```\n\nThe `dbClient` uses the named params to pass all the attributes and provides the `options` property in the type of\n[jdbc:Options](https:\/\/docs.central.ballerina.io\/ballerinax\/java.jdbc\/latest\/records\/Options),\nand also uses the unshared connection pool in the type of\n[sql:ConnectionPool](https:\/\/docs.central.ballerina.io\/ballerina\/sql\/latest\/records\/ConnectionPool).\nFor more information about connection pooling, see the [`sql` module](https:\/\/docs.central.ballerina.io\/ballerina\/sql\/latest).\n\nE.g., The DB client creation for an H2 database will be as follows.\n```ballerina\njdbc:Client|sql:Error dbClient = new (url =  \"jdbc:h2:~\/path\/to\/database\",\n                             user = \"root\", password = \"root\",\n                             options = {\n                                 datasourceName: \"org.h2.jdbcx.JdbcDataSource\"\n                             },\n                             connectionPool = {\n                                 maxOpenConnections: 5\n                             });\n```\n\nThe `dbClient` receives some custom properties within the\n[jdbc:Options](https:\/\/docs.central.ballerina.io\/ballerinax\/java.jdbc\/latest\/records\/Options),   \nand those properties will be used by the defined `datasourceName`.\nAs per the provided example, the `org.h2.jdbcx.JdbcDataSource` datasource  will be configured with a `loginTimeout`\nof `2000` milliseconds.\n\nE.g., The DB client creation for an H2 database will be as follows.\n```ballerina\njdbc:Client|sql:Error dbClient = new (url =  \"jdbc:h2:~\/path\/to\/database\", \n                             user = \"root\", password = \"root\",\n                             options = {\n                                datasourceName: \"org.h2.jdbcx.JdbcDataSource\", \n                                properties: {\"loginTimeout\": \"2000\"}\n                             });                          \n```\n\nYou can find more details about each property in the\n[jdbc:Client](https:\/\/docs.central.ballerina.io\/ballerinax\/java.jdbc\/latest\/clients\/Client) constructor.\n\nThe [jdbc:Client](https:\/\/docs.central.ballerina.io\/ballerinax\/java.jdbc\/latest\/clients\/Client) references\n[sql:Client](https:\/\/docs.central.ballerina.io\/ballerina\/sql\/latest\/clients\/Client) and\nall the operations defined by the `sql:Client` will be supported by the `jdbc:Client` as well.\n\n#### Connection Pool Handling\n\nAll ballerina database modules share the same connection pooling concept and there are three possible scenarios for\nconnection pool handling.  For its properties and possible values, see the [`sql:ConnectionPool`](https:\/\/docs.central.ballerina.io\/ballerina\/sql\/latest\/records\/ConnectionPool).\n\n1. Global shareable default connection pool\n\n   If you do not provide the `poolOptions` field when creating the database client, a globally-shareable pool will be\n   created for your database unless a connection pool matching with the properties you provided already exists.\n   The JDBC module example below shows how the global connection pool is used.\n\n   E.g., The DB client creation for an H2 database is as follows.\n   ```ballerina\n    jdbc:Client|sql:Error dbClient = \n                               new (\"jdbc:h2:~\/path\/to\/database\", \n                                \"root\", \"root\");\n    ```\n\n2. Client owned, unsharable connection pool\n\n   If you define the `connectionPool` field inline when creating the database client with the `sql:ConnectionPool` type,\n   an unsharable connection pool will be created. The JDBC module example below shows how the global\n   connection pool is used.\n\n   E.g., The DB client creation for an H2 database is as follows.\n    ```ballerina\n    jdbc:Client|sql:Error dbClient = \n                               new (url = \"jdbc:h2:~\/path\/to\/database\", \n                               connectionPool = { maxOpenConnections: 5 });\n    ```\n\n3. Local, shareable connection pool\n\n   If you create a record of type `sql:ConnectionPool` and reuse that in the configuration of multiple clients,\n   for each set of clients that connects to the same database instance with the same set of properties, a shared\n   connection pool will be created. The JDBC module example below shows how the global connection pool is used.\n\n   E.g., The DB client creation for an H2 database is as follows.\n    ```ballerina\n    sql:ConnectionPool connPool = {maxOpenConnections: 5};\n    \n    jdbc:Client|sql:Error dbClient1 =       \n                               new (url = \"jdbc:h2:~\/path\/to\/database\",\n                               connectionPool = connPool);\n    jdbc:Client|sql:Error dbClient2 = \n                               new (url = \"jdbc:h2:~\/path\/to\/database\",\n                               connectionPool = connPool);\n    jdbc:Client|sql:Error dbClient3 = \n                               new (url = \"jdbc:h2:~\/path\/to\/database\",\n                               connectionPool = connPool);\n    ```\n   \n#### Closing the Client\n\nOnce all the database operations are performed, you can close the database client you have created by invoking the `close()`\noperation. This will close the corresponding connection pool if it is not shared by any other database clients. \n\n```ballerina\nerror? e = dbClient.close();\n```\nOr\n```ballerina\ncheck dbClient.close();\n```\n\n### Database Operations\n\nOnce the client is created, database operations can be executed through that client. This module defines the interface\nand common properties that are shared among multiple database clients.  It also supports querying, inserting, deleting,\nupdating, and batch updating data.\n\n#### Creating Tables\n\nThis sample creates a table with two columns. One column is of type `int` and the other is of type `varchar`.\nThe `CREATE` statement is executed via the `execute` remote function of the client.\n\n```ballerina\n\/\/ Create the ‘Students’ table with the  ‘id’, 'name', and ‘age’ fields.\nsql:ExecutionResult ret = check dbClient->execute(\"CREATE TABLE student(id INT AUTO_INCREMENT, \" +\n                         \"age INT, name VARCHAR(255), PRIMARY KEY (id))\");\n\/\/A value of the sql:ExecutionResult type is returned for 'ret'. \n```\n\n#### Inserting Data\n\nThis sample shows three examples of data insertion by executing an `INSERT` statement using the `execute` remote function\nof the client.\n\nIn the first example, the query parameter values are passed directly into the query statement of the `execute`\nremote function.\n\n```ballerina\nsql:ExecutionResult ret = check dbClient->execute(\"INSERT INTO student(age, name) \" +\n                         \"values (23, 'john')\");\n```\n\nIn the second example, the parameter values, which are in local variables are used to parameterize the SQL query in\nthe `execute` remote function. This type of parameterized SQL query can be used with any primitive Ballerina type\nlike `string`, `int`, `float`, or `boolean` and in that case, the corresponding SQL type of the parameter is derived\nfrom the type of the Ballerina variable that is passed in.\n\n```ballerina\nstring name = \"Anne\";\nint age = 8;\n\nsql:ParameterizedQuery query = `INSERT INTO student(age, name)\n                                values (${age}, ${name})`;\nsql:ExecutionResult ret = check dbClient->execute(query);\n```\n\nIn the third example, the parameter values are passed as a `sql:TypedValue` to the `execute` remote function. Use the\ncorresponding subtype of the `sql:TypedValue` such as `sql:Varchar`, `sql:Char`, `sql:Integer`, etc., when you need to\nprovide more details such as the exact SQL type of the parameter.\n\n```ballerina\nsql:VarcharValue name = new (\"James\");\nsql:IntegerValue age = new (10);\n\nsql:ParameterizedQuery query = `INSERT INTO student(age, name)\n                                values (${age}, ${name})`;\nsql:ExecutionResult ret = check dbClient->execute(query);\n```\n\n#### Inserting Data With Auto-generated Keys\n\nThis example demonstrates inserting data while returning the auto-generated keys. It achieves this by using the\n`execute` remote function to execute the `INSERT` statement.\n\n```ballerina\nint age = 31;\nstring name = \"Kate\";\n\nsql:ParameterizedQuery query = `INSERT INTO student(age, name)\n                                values (${age}, ${name})`;\nsql:ExecutionResultret = check dbClient->execute(query);\n\/\/Number of rows affected by the execution of the query.\nint? count = ret.affectedRowCount;\n\/\/The integer or string generated by the database in response to a query execution.\nstring|int? generatedKey = ret.lastInsertId;\n}\n```\n\n#### Querying Data\n\nThis sample shows three examples to demonstrate the different usages of the `query` operation and query the\ndatabase table and obtain the results.\n\nThis example demonstrates querying data from a table in a database.\nFirst, a type is created to represent the returned result set. Note that the mapping of the database column\nto the returned record's property is case-insensitive (i.e., the `ID` column in the result can be mapped to the `id`\nproperty in the record). Next, the `SELECT` query is executed via the `query` remote function of the client by passing that\nresult set type. Once the query is executed, each data record can be retrieved by looping the result set. The `stream`\nreturned by the select operation holds a pointer to the actual data in the database and it loads data from the table\nonly when it is accessed. This stream can be iterated only once.\n\n```ballerina\n\/\/ Define a type to represent the results.\ntype Student record {\n    int id;\n    int age;\n    string name;\n};\n\n\/\/ Select the data from the database table. The query parameters are passed \n\/\/ directly. Similar to the `execute` examples, parameters can be passed as\n\/\/ sub types of `sql:TypedValue` as well.\nint id = 10;\nint age = 12;\nsql:ParameterizedQuery query = `SELECT * FROM students\n                                WHERE id < ${id} AND age > ${age}`;\nstream<Student, sql:Error> resultStream = \n        <stream<Student, sql:Error>> dbClient->query(query, Student);\n\n\/\/ Iterating the returned table.\nerror? e = resultStream.forEach(function(Student student) {\n   \/\/Can perform any operations using 'student' and can access any fields in the returned record of type Student.\n});\n```\n\nDefining the return type is optional and you can query the database without providing the result type. Hence,\nthe above example can be modified as follows with an open record type as the return type. The property name in the open record\ntype will be the same as how the column is defined in the database.\n\n```ballerina\n\/\/ Select the data from the database table. The query parameters are passed \n\/\/ directly. Similar to the `execute` examples, parameters can be passed as \n\/\/ sub types of `sql:TypedValue` as well.\nint id = 10;\nint age = 12;\nsql:ParameterizedQuery query = `SELECT * FROM students\n                                WHERE id < ${id} AND age > ${age}`;\nstream<record{}, sql:Error> resultStream = dbClient->query(query);\n\n\/\/ Iterating the returned table.\nerror? e = resultStream.forEach(function(record{} student) {\n    \/\/Can perform any operations using 'student' and can access any fields in the returned record.\n});\n```\n\nThere are situations in which you may not want to iterate through the database and in that case, you may decide\nto only use the `next()` operation in the result `stream` and retrieve the first record. In such cases, the returned\nresult stream will not be closed and you have to explicitly invoke the `close` operation on the\n`sql:Client` to release the connection resources and avoid a connection leak as shown below.\n\n```ballerina\nstream<record{}, sql:Error> resultStream = \n            dbClient->query(\"SELECT count(*) as total FROM students\");\n\nrecord {|record {} value;|}|error? result = resultStream.next();\n\nif result is record {|record {} value;|} {\n    \/\/valid result is returned.\n} else if result is error {\n    \/\/ An error is returned as the result.\n} else {\n    \/\/ Student table must be empty.\n}\n\nerror? e = resultStream.close();\n```\n\n#### Updating Data\n\nThis example demonstrates modifying data by executing an `UPDATE` statement via the `execute` remote function of\nthe client.\n\n```ballerina\nint age = 23;\nsql:ParameterizedQuery query = `UPDATE students SET name = 'John' \n                                WHERE age = ${age}`;\nsql:ExecutionResult|sql:Error ret = check dbClient->execute(query);\n```\n\n#### Deleting Data\n\nThis example demonstrates deleting data by executing a `DELETE` statement via the `execute` remote function of\nthe client.\n\n```ballerina\nstring name = \"John\";\nsql:ParameterizedQuery query = `DELETE from students WHERE name = ${name}`;\nsql:ExecutionResult|sql:Error ret = check dbClient->execute(query);\n```\n\n#### Batch Updating Data\n\nThis example demonstrates how to insert multiple records with a single `INSERT` statement that is executed via the\n`batchExecute` remote function of the client. This is done by creating a `table` with multiple records and\nparameterized SQL query as same as the  above `execute` operations.\n\n```ballerina\n\/\/ Create the table with the records that need to be inserted.\nvar data = [\n  { name: \"John\", age: 25  },\n  { name: \"Peter\", age: 24 },\n  { name: \"jane\", age: 22 }\n];\n\n\/\/ Do the batch update by passing the batches.\nsql:ParameterizedQuery[] batch = from var row in data\n                                 select `INSERT INTO students ('name', 'age')\n                                 VALUES (${row.name}, ${row.age})`;\nsql:ExecutionResult[] ret = check dbClient->batchExecute(batch);\n```\n\n#### Execute SQL Stored Procedures\n\nThis example demonstrates how to execute a stored procedure with a single `INSERT` statement that is executed via the\n`call` remote function of the client.\n\n```ballerina\nint uid = 10;\nsql:IntegerOutParameter insertId = new;\n\nsql:ProcedureCallResult|sql:Error ret = dbClient->call(`call InsertPerson(${uid}, ${insertId})`);\nif ret is error {\n    \/\/An error returned\n} else {\n    stream<record{}, sql:Error>? resultStr = ret.queryResult;\n    if resultStr is stream<record{}, sql:Error> {\n        sql:Error? e = resultStr.forEach(function(record{} result) {\n        \/\/can perform operations using 'result'.\n      });\n    }\n    check ret.close();\n}\n```\nNote that you have to explicitly invoke the close operation on the `sql:ProcedureCallResult` to release the connection resources and avoid a connection leak as shown above.\n\n>**Note:** The default thread pool size used in Ballerina is: [the number of processors available * 2]. You can configure\nthe thread pool size by using the `BALLERINA_MAX_POOL_SIZE` environment variable.", "apiDocURL":"https://docs.central.ballerina.io/ballerinax/java.jdbc/0.6.0-beta.1", "packageUrl":"/ballerinax/java.jdbc/0.6.0-beta.1"}], "pullCount":7}, {"organization":"ballerinax", "name":"mysql", "version":"0.7.0-beta.1", "platform":"java11", "languageSpecificationVersion":"2021R1", "URL":"/ballerinax/mysql/0.7.0-beta.1", "balaVersion":"2.0.0", "balaURL":"https://fileserver.central.ballerina.io/2.0/ballerinax/mysql/0.7.0-beta.1/ballerinax-mysql-java11-0.7.0-beta.1.bala", "digest":"sha-256=ee6538d4b412e5c55260ea2916661936568dcfce0ab36ea4304db7fd550cd39f", "summary":"", "readme":"## Package overview\n\nThe `mysql` library is one of the external library packages of the<a target=\"_blank\" href=\"https:\/\/ballerina.io\/\"> Ballerina<\/a> language.  This external package is maintained by the Ballerina team.\n\nThis provides the functionality required to access and manipulate data stored in a MySQL database.\n\n### Report Issues\n\nTo report bugs, request new features, start new discussions, view project boards, etc., go to the [Ballerina Standard Library parent repository](https:\/\/github.com\/ballerina-platform\/ballerina-standard-library).\n\n### Useful Links\n- Discuss code changes of the Ballerina project in ballerina-dev@googlegroups.com.\n- Chat live with us via our [Slack channel](https:\/\/ballerina.io\/community\/slack\/).\n- Post all technical questions on Stack Overflow with the [#ballerina](https:\/\/stackoverflow.com\/questions\/tagged\/ballerina) tag", "template":false, "licenses":[], "authors":[], "sourceCodeLocation":"", "keywords":[], "ballerinaVersion":"slbeta1", "icon":"", "createdDate":1622649953000, "modules":[{"name":"mysql", "summary":"", "readme":"## Overview\n\nThis module provides the functionality required to access and manipulate data stored in a MySQL database.\n\n**Prerequisite:** Add the MySQL driver JAR as a native library dependency in your Ballerina project.\nThis module uses the database properties from the MySQL version 8.0.13 onwards. Therefore, it is recommended to use a\nMySQL driver version greater than 8.0.13. Then, once you build the project by executing the `ballerina build`\ncommand, you should be able to run the resultant by executing the `ballerina run` command.\n\nE.g., The `Ballerina.toml` content.\nChange the path to the JDBC driver appropriately.\n\n```toml\n[package]\norg = \"sample\"\nname = \"mysql\"\nversion= \"0.1.0\"\n\n[[platform.java11.dependency]]\nartifactId = \"mysql-connector-java\"\nversion = \"8.0.17\"\npath = \"\/path\/to\/mysql-connector-java-8.0.17.jar\"\ngroupId = \"mysql\"\n``` \n\n### Client\nTo access a database, you must first create a\n[mysql:Client](https:\/\/docs.central.ballerina.io\/ballerinax\/mysql\/latest\/clients\/Client) object.\nThe examples for creating a MySQL client can be found below.\n\n#### Creating a Client\nThis example shows the different ways of creating the `mysql:Client`.\n\nThe client can be created with an empty constructor, and thereby, the client will be initialized with the default properties.\n\n```ballerina\nmysql:Client|sql:Error dbClient = new ();\n```\n\nThe `dbClient` receives the host, username, and password. Since the properties are passed in the same order as they are defined\nin the `jdbc:Client`, you can pass them without named params.\n\n```ballerina\nmysql:Client|sql:Error dbClient = new (\"localhost\", \"rootUser\", \"rooPass\", \n                              \"information_schema\", 3306);\n```\n\nThe `dbClient` uses the named params to pass the attributes since it is skipping some params in the constructor.\nFurther, the [`mysql:Options`](https:\/\/docs.central.ballerina.io\/ballerinax\/mysql\/latest\/records\/Options)\nproperty is passed to configure the SSL and connection timeout in the MySQL client.\n\n```ballerina\nmysql:Options mysqlOptions = {\n  ssl: {\n    mode: mysql:SSL_PREFERRED\n  },\n  connectTimeout: 10\n};\nmysql:Client|sql:Error dbClient = new (user = \"rootUser\", password = \"rootPass\",\n                              options = mysqlOptions);\n```\n\nSimilarly, the `dbClient` uses the named params and it provides an unshared connection pool of the type of\n[sql:ConnectionPool](https:\/\/docs.central.ballerina.io\/ballerina\/sql\/latest\/records\/ConnectionPool)\nto be used within the client.\nFor more details about connection pooling, see the [`sql` Module](https:\/\/docs.central.ballerina.io\/ballerina\/sql\/latest).\n\n```ballerina\nmysql:Client|sql:Error dbClient = new (user = \"rootUser\", password = \"rootPass\",\n                              connectionPool = {maxOpenConnections: 5});\n```\n\n#### Using SSL\nTo connect the MySQL database using an SSL connection, you must add the SSL configurations to the `mysql:Options` when creating the `dbClient`.\nFor the SSL Mode, you can select one of the modes: `mysql:SSL_PREFERRED`, `mysql:SSL_REQUIRED`, `mysql:SSL_VERIFY_CA`, or `mysql:SSL_VERIFY_IDENTITY` according to the requirement.\nFor the key and cert files, you must provide the files in the `.p12` format.\n\n```ballerina\nstring clientStorePath = \"\/path\/to\/keystore.p12\";\nstring turstStorePath = \"\/path\/to\/truststore.p12\";\n\nmysql:Options mysqlOptions = {\n  ssl: {\n    mode: mysql:SSL_PREFERRED,\n    key: {\n        path: clientStorePath,\n        password: \"password\"\n    },\n    cert: {\n        path: turstStorePath,\n        password: \"password\"\n    }\n  }\n};\n```\n#### Connection Pool Handling\n\nAll database modules share the same connection pooling concept and there are three possible scenarios for \nconnection pool handling.  For its properties and possible values, see the [`sql:ConnectionPool`](https:\/\/docs.central.ballerina.io\/ballerina\/sql\/latest\/records\/ConnectionPool).\n\n1. Global, shareable, default connection pool\n\n    If you do not provide the `poolOptions` field when creating the database client, a globally-shareable pool will be \n    created for your database unless a connection pool matching with the properties you provided already exists. \n    The JDBC module example below shows how the global connection pool is used. \n\n    ```ballerina\n    jdbc:Client|sql:Error dbClient = \n                               new (\"jdbc:mysql:\/\/localhost:3306\/testdb\", \n                                \"root\", \"root\");\n    ```\n\n2. Client owned, unsharable connection pool\n\n    If you define the `connectionPool` field inline when creating the database client with the `sql:ConnectionPool` type, \n    an unsharable connection pool will be created. The JDBC module example below shows how the global \n    connection pool is used.\n\n    ```ballerina\n    jdbc:Client|sql:Error dbClient = \n                               new (url = \"jdbc:mysql:\/\/localhost:3306\/testdb\", \n                               connectionPool = { maxOpenConnections: 5 });\n    ```\n\n3. Local, shareable connection pool\n\n    If you create a record of type `sql:ConnectionPool` and reuse that in the configuration of multiple clients, \n    for each set of clients that connects to the same database instance with the same set of properties, a shared \n    connection pool will be created. The JDBC module example below shows how the global connection pool is used.\n\n    ```ballerina\n    sql:ConnectionPool connPool = {maxOpenConnections: 5};\n    \n    jdbc:Client|sql:Error dbClient1 =       \n                               new (url = \"jdbc:mysql:\/\/localhost:3306\/testdb\",\n                               connectionPool = connPool);\n    jdbc:Client|sql:Error dbClient2 = \n                               new (url = \"jdbc:mysql:\/\/localhost:3306\/testdb\",\n                               connectionPool = connPool);\n    jdbc:Client|sql:Error dbClient3 = \n                               new (url = \"jdbc:mysql:\/\/localhost:3306\/testdb\",\n                               connectionPool = connPool);\n    ```\n   \nFor more details about each property, see the [`mysql:Client`](https:\/\/docs.central.ballerina.io\/ballerinax\/mysql\/latest\/clients\/Client) constructor.\n\nThe [mysql:Client](https:\/\/docs.central.ballerina.io\/ballerinax\/mysql\/latest\/clients\/Client) references\n[sql:Client](https:\/\/docs.central.ballerina.io\/ballerina\/sql\/latest\/clients\/Client) and all the operations\ndefined by the `sql:Client` will be supported by the `mysql:Client` as well.\n \n#### Closing the Client\n\nOnce all the database operations are performed, you can close the database client you have created by invoking the `close()`\noperation. This will close the corresponding connection pool if it is not shared by any other database clients. \n\n```ballerina\nerror? e = dbClient.close();\n```\nor\n```ballerina\ncheck dbClient.close();\n```\n\n### Database Operations\n\nOnce the client is created, database operations can be executed through that client. This module defines the interface \nand common properties that are shared among multiple database clients.  It also supports querying, inserting, deleting, \nupdating, and batch updating data.  \n\n#### Creating Tables\n\nThis sample creates a table with two columns. One column is of type `int` and the other is of type `varchar`.\nThe `CREATE` statement is executed via the `execute` remote function of the client.\n\n```ballerina\n\/\/ Create the ‘Students’ table with the  ‘id’, 'name', and ‘age’ fields.\nsql:ExecutionResult ret = check dbClient->execute(\"CREATE TABLE student(id INT AUTO_INCREMENT, \" +\n                         \"age INT, name VARCHAR(255), PRIMARY KEY (id))\");\n\/\/A value of the`sql:ExecutionResult` type is returned for 'ret'. \n```\n\n#### Inserting Data\n\nThis sample shows three examples of data insertion by executing an `INSERT` statement using the `execute` remote function \nof the client.\n\nIn the first example, the query parameter values are passed directly into the query statement of the `execute` \nremote function.\n\n```ballerina\nsql:ExecutionResult ret = check dbClient->execute(\"INSERT INTO student(age, name) \" +\n                         \"values (23, 'john')\");\n```\n\nIn the second example, the parameter values, which are in local variables are used to parameterize the SQL query in \nthe `execute` remote function. This type of a parameterized SQL query can be used with any primitive Ballerina type \nlike `string`, `int`, `float`, or `boolean` and in that case, the corresponding SQL type of the parameter is derived \nfrom the type of the Ballerina variable that is passed in. \n\n```ballerina\nstring name = \"Anne\";\nint age = 8;\n\nsql:ParameterizedQuery query = `INSERT INTO student(age, name)\n                                values (${age}, ${name})`;\nsql:ExecutionResult ret = check dbClient->execute(query);\n```\n\nIn the third example, the parameter values are passed as an `sql:TypedValue` to the `execute` remote function. Use the \ncorresponding subtype of the `sql:TypedValue` such as `sql:Varchar`, `sql:Char`, `sql:Integer`, etc. when you need to \nprovide more details such as the exact SQL type of the parameter.\n\n```ballerina\nsql:VarcharValue name = new (\"James\");\nsql:IntegerValue age = new (10);\n\nsql:ParameterizedQuery query = `INSERT INTO student(age, name)\n                                values (${age}, ${name})`;\nsql:ExecutionResult ret = check dbClient->execute(query);\n```\n\n#### Inserting Data With Auto-generated Keys\n\nThis example demonstrates inserting data while returning the auto-generated keys. It achieves this by using the \n`execute` remote function to execute the `INSERT` statement.\n\n```ballerina\nint age = 31;\nstring name = \"Kate\";\n\nsql:ParameterizedQuery query = `INSERT INTO student(age, name)\n                                values (${age}, ${name})`;\nsql:ExecutionResultret = check dbClient->execute(query);\n\/\/Number of rows affected by the execution of the query.\nint? count = ret.affectedRowCount;\n\/\/The integer or string generated by the database in response to a query execution.\nstring|int? generatedKey = ret.lastInsertId;\n}\n```\n\n#### Querying Data\n\nThis sample shows three examples to demonstrate the different usages of the `query` operation to query the\ndatabase table and obtain the results. \n\nThis example demonstrates querying data from a table in a database. \nFirst, a type is created to represent the returned result set. Note the mapping of the database column \nto the returned record's property is case-insensitive (i.e., the `ID` column in the result can be mapped to the `id` \nproperty in the record). Next, the `SELECT` query is executed via the `query` remote function of the client by passing that \nresult set type. Once the query is executed, each data record can be retrieved by looping the result set. The `stream` \nreturned by the `SELECT` operation holds a pointer to the actual data in the database and it loads data from the table \nonly when it is accessed. This stream can be iterated only once. \n\n```ballerina\n\/\/ Define a type to represent the results.\ntype Student record {\n    int id;\n    int age;\n    string name;\n};\n\n\/\/ Select the data from the database table. The query parameters are passed \n\/\/ directly. Similar to the `execute` examples, parameters can be passed as\n\/\/ sub types of `sql:TypedValue` as well.\nint id = 10;\nint age = 12;\nsql:ParameterizedQuery query = `SELECT * FROM students\n                                WHERE id < ${id} AND age > ${age}`;\nstream<Student, sql:Error> resultStream = \n        <stream<Student, sql:Error>> dbClient->query(query, Student);\n\n\/\/ Iterating the returned table.\nerror? e = resultStream.forEach(function(Student student) {\n   \/\/Can perform any operations using 'student' and can access any fields in the returned record of type `Student`.\n});\n```\n\nDefining the return type is optional and you can query the database without providing the result type. Hence, \nthe above example can be modified as follows with an open record type as the return type. The property name in the open record \ntype will be the same as how the column is defined in the database. \n\n```ballerina\n\/\/ Select the data from the database table. The query parameters are passed \n\/\/ directly. Similar to the `execute` examples, parameters can be passed as \n\/\/ sub types of `sql:TypedValue` as well.\nint id = 10;\nint age = 12;\nsql:ParameterizedQuery query = `SELECT * FROM students\n                                WHERE id < ${id} AND age > ${age}`;\nstream<record{}, sql:Error> resultStream = dbClient->query(query);\n\n\/\/ Iterating the returned table.\nerror? e = resultStream.forEach(function(record{} student) {\n    \/\/Can perform any operations using 'student' and can access any fields in the returned record.\n});\n```\n\nThere are situations in which you may not want to iterate through the database and in that case, you may decide\nto only use the `next()` operation in the result `stream` and retrieve the first record. In such cases, the returned\nresult stream will not be closed and you have to invoke the `close` operation explicitly on the \n`sql:Client` to release the connection resources and avoid a connection leak as shown below.\n\n```ballerina\nstream<record{}, sql:Error> resultStream = \n            dbClient->query(\"SELECT count(*) as total FROM students\");\n\nrecord {|record {} value;|}|error? result = resultStream.next();\n\nif result is record {|record {} value;|} {\n    \/\/A valid result is returned.\n} else if result is error {\n    \/\/ An error is returned as the result.\n} else {\n    \/\/ The `Student` table must be empty.\n}\n\nerror? e = resultStream.close();\n```\n\n#### Updating Data\n\nThis example demonstrates modifying data by executing an `UPDATE` statement via the `execute` remote function of \nthe client.\n\n```ballerina\nint age = 23;\nsql:ParameterizedQuery query = `UPDATE students SET name = 'John' \n                                WHERE age = ${age}`;\nsql:ExecutionResult|sql:Error ret = check dbClient->execute(query);\n```\n\n#### Deleting Data\n\nThis example demonstrates deleting data by executing a `DELETE` statement via the `execute` remote function of \nthe client.\n\n```ballerina\nstring name = \"John\";\nsql:ParameterizedQuery query = `DELETE from students WHERE name = ${name}`;\nsql:ExecutionResult|sql:Error ret = check dbClient->execute(query);\n```\n\n#### Batch Updating Data\n\nThis example demonstrates how to insert multiple records with a single `INSERT` statement that is executed via the \n`batchExecute` remote function of the client. This is done by creating a `table` with multiple records and \nparameterized SQL query as same as the  above `execute` operations.\n\n```ballerina\n\/\/ Create the table with the records that need to be inserted.\nvar data = [\n  { name: \"John\", age: 25  },\n  { name: \"Peter\", age: 24 },\n  { name: \"jane\", age: 22 }\n];\n\n\/\/ Do the batch update by passing the batches.\nsql:ParameterizedQuery[] batch = from var row in data\n                                 select `INSERT INTO students ('name', 'age')\n                                 VALUES (${row.name}, ${row.age})`;\nsql:ExecutionResult[] ret = check dbClient->batchExecute(batch);\n```\n\n#### Execute SQL Stored Procedures\n\nThis example demonstrates how to execute a stored procedure with a single `INSERT` statement that is executed via the \n`call` remote function of the client.\n\n```ballerina\nint uid = 10;\nsql:IntegerOutParameter insertId = new;\n\nsql:ProcedureCallResult|sql:Error ret = dbClient->call(`call InsertPerson(${uid}, ${insertId})`);\nif ret is error {\n    \/\/An error returned\n} else {\n    stream<record{}, sql:Error>? resultStr = ret.queryResult;\n    if resultStr is stream<record{}, sql:Error> {\n        sql:Error? e = resultStr.forEach(function(record{} result) {\n        \/\/can perform operations using 'result'.\n      });\n    }\n    check ret.close();\n}\n```\n\nNote that you have to invoke the close operation on the `sql:ProcedureCallResult` explicitly to release the connection resources and avoid a connection leak as shown above.\n\n>**Note:** The default thread pool size used in Ballerina is: [the number of processors available * 2]. You can configure\nthe thread pool size by using the `BALLERINA_MAX_POOL_SIZE` environment variable.\n> ", "apiDocURL":"https://docs.central.ballerina.io/ballerinax/mysql/0.7.0-beta.1", "packageUrl":"/ballerinax/mysql/0.7.0-beta.1"}], "pullCount":7}, {"organization":"ballerina", "name":"sql", "version":"0.6.0-beta.1", "platform":"java11", "languageSpecificationVersion":"2021R1", "URL":"/ballerina/sql/0.6.0-beta.1", "balaVersion":"2.0.0", "balaURL":"https://fileserver.central.ballerina.io/2.0/ballerina/sql/0.6.0-beta.1/ballerina-sql-java11-0.6.0-beta.1.bala", "digest":"sha-256=528214d75b78d3f14b15f1aede0b8ed1c2f3ec1c6ef5c8eeeed0d5f1ffac0a8d", "summary":"", "readme":"## Package Overview\n\nThe SQL library is one of the standard library packages of the<a target=\"_blank\" href=\"https:\/\/ballerina.io\/\"> Ballerina<\/a> language.\n\nIt provides the common interface and functionality to interact with a database. The corresponding database clients can be created by using specific database packages such as MySQL or using the Java Database Connectivity package JDBC.\n\n### Report Issues\n\nTo report bugs, request new features, start new discussions, view project boards, etc., go to the [Ballerina Standard Library parent repository](https:\/\/github.com\/ballerina-platform\/ballerina-standard-library).\n\n### Useful Links\n- Discuss the code changes of the Ballerina project in ballerina-dev@googlegroups.com.\n- Chat live with us via our [Slack channel](https:\/\/ballerina.io\/community\/slack\/).\n- Post all technical questions on Stack Overflow with the [#ballerina](https:\/\/stackoverflow.com\/questions\/tagged\/ballerina) tag.", "template":false, "licenses":[], "authors":[], "sourceCodeLocation":"", "keywords":[], "ballerinaVersion":"slbeta1", "icon":"", "createdDate":1622649565000, "modules":[{"name":"sql", "summary":"", "readme":"## Overview\n\nThis module provides the common interface and functionality to interact with a database. The corresponding database\nclients can be created by using specific database modules such as `mysql` or using the Java Database Connectivity \nmodule `jdbc`.\n\n### List of Database Modules\nBallerina now has the [`jdbc` module](https:\/\/docs.central.ballerina.io\/ballerinax\/java.jdbc\/latest) as the generic DB connector module to connect to any relational database by simply providing the JDBC URL and the other related properties.\nBallerina also provides specially designed various database-specific DB connectors so that you can work with different databases and you can access their DB-specific functionalities.\n\n### Client\n\nThe database client should be created using any of the above-listed database modules and once it is created, the operations and functionality explained below can be used. \n\n#### Connection Pool Handling\n\nAll database modules share the same connection pooling concept and there are three possible scenarios for \nconnection pool handling.  For its properties and possible values, see the [`sql:ConnectionPool`](https:\/\/docs.central.ballerina.io\/ballerina\/sql\/latest\/records\/ConnectionPool).  \n\n1. Global, shareable, default connection pool\n\n    If you do not provide the `poolOptions` field when creating the database client, a globally-shareable pool will be \n    created for your database unless a connection pool matching with the properties you provided already exists. \n    The JDBC module example below shows how the global connection pool is used. \n\n    ```ballerina\n    jdbc:Client|sql:Error dbClient = \n                               new (\"jdbc:mysql:\/\/localhost:3306\/testdb\", \n                                \"root\", \"root\");\n    ```\n\n2. Client-owned, unsharable connection pool\n\n    If you define the `connectionPool` field inline when creating the database client with the `sql:ConnectionPool` type, \n    an unsharable connection pool will be created. The JDBC module example below shows how the global \n    connection pool is used.\n\n    ```ballerina\n    jdbc:Client|sql:Error dbClient = \n                               new (url = \"jdbc:mysql:\/\/localhost:3306\/testdb\", \n                               connectionPool = { maxOpenConnections: 5 });\n    ```\n\n3. Local, shareable connection pool\n\n    If you create a record of the `sql:ConnectionPool` type and reuse that in the configuration of multiple clients, \n    for each set of clients that connects to the same database instance with the same set of properties, a shared \n    connection pool will be created. The JDBC module example below shows how the global connection pool is used.\n\n    ```ballerina\n    sql:ConnectionPool connPool = {maxOpenConnections: 5};\n    \n    jdbc:Client|sql:Error dbClient1 =       \n                               new (url = \"jdbc:mysql:\/\/localhost:3306\/testdb\",\n                               connectionPool = connPool);\n    jdbc:Client|sql:Error dbClient2 = \n                               new (url = \"jdbc:mysql:\/\/localhost:3306\/testdb\",\n                               connectionPool = connPool);\n    jdbc:Client|sql:Error dbClient3 = \n                               new (url = \"jdbc:mysql:\/\/localhost:3306\/testdb\",\n                               connectionPool = connPool);\n    ```\n    \n#### Closing the Client\n\nOnce all the database operations are performed, you can close the database client you have created by invoking the `close()`\noperation. This will close the corresponding connection pool if it is not shared by any other database clients. \n\n```ballerina\nerror? e = dbClient.close();\n```\nOr\n```ballerina\ncheck dbClient.close();\n```\n\n### Database Operations\n\nOnce the client is created, database operations can be executed through that client. This module defines the interface \nand common properties that are shared among multiple database clients.  It also supports querying, inserting, deleting, \nupdating, and batch updating data.  \n\n#### Creating Tables\n\nThis sample creates a table with two columns. One column is of type `int` and the other is of type `varchar`.\nThe `CREATE` statement is executed via the `execute` remote function of the client.\n\n```ballerina\n\/\/ Create the ‘Students’ table with the  ‘id’, 'name', and ‘age’ fields.\nsql:ExecutionResult ret = check dbClient->execute(\"CREATE TABLE student(id INT AUTO_INCREMENT, \" +\n                         \"age INT, name VARCHAR(255), PRIMARY KEY (id))\");\n\/\/A value of the sql:ExecutionResult type is returned for 'ret'. \n```\n\n#### Inserting Data\n\nThis sample shows three examples of data insertion by executing an `INSERT` statement using the `execute` remote function \nof the client.\n\nIn the first example, the query parameter values are passed directly into the query statement of the `execute` \nremote function.\n\n```ballerina\nsql:ExecutionResult ret = check dbClient->execute(\"INSERT INTO student(age, name) \" +\n                         \"values (23, 'john')\");\n```\n\nIn the second example, the parameter values, which are in local variables are used to parameterize the SQL query in \nthe `execute` remote function. This type of a parameterized SQL query can be used with any primitive Ballerina type \nlike `string`, `int`, `float`, or `boolean` and in that case, the corresponding SQL type of the parameter is derived \nfrom the type of the Ballerina variable that is passed in. \n\n```ballerina\nstring name = \"Anne\";\nint age = 8;\n\nsql:ParameterizedQuery query = `INSERT INTO student(age, name)\n                                values (${age}, ${name})`;\nsql:ExecutionResult ret = check dbClient->execute(query);\n```\n\nIn the third example, the parameter values are passed as a `sql:TypedValue` to the `execute` remote function. Use the \ncorresponding subtype of the `sql:TypedValue` such as `sql:Varchar`, `sql:Char`, `sql:Integer`, etc., when you need to \nprovide more details such as the exact SQL type of the parameter.\n\n```ballerina\nsql:VarcharValue name = new (\"James\");\nsql:IntegerValue age = new (10);\n\nsql:ParameterizedQuery query = `INSERT INTO student(age, name)\n                                values (${age}, ${name})`;\nsql:ExecutionResult ret = check dbClient->execute(query);\n```\n\n#### Inserting Data With Auto-generated Keys\n\nThis example demonstrates inserting data while returning the auto-generated keys. It achieves this by using the \n`execute` remote function to execute the `INSERT` statement.\n\n```ballerina\nint age = 31;\nstring name = \"Kate\";\n\nsql:ParameterizedQuery query = `INSERT INTO student(age, name)\n                                values (${age}, ${name})`;\nsql:ExecutionResultret = check dbClient->execute(query);\n\/\/Number of rows affected by the execution of the query.\nint? count = ret.affectedRowCount;\n\/\/The integer or string generated by the database in response to a query execution.\nstring|int? generatedKey = ret.lastInsertId;\n}\n```\n\n#### Querying Data\n\nThis sample shows three examples to demonstrate the different usages of the `query` operation to query the\ndatabase table and obtain the results. \n\nThis example demonstrates querying data from a table in a database. \nFirst, a type is created to represent the returned result set. Note the mapping of the database column \nto the returned record's property is case-insensitive (i.e., the `ID` column in the result can be mapped to the `id` \nproperty in the record). Next, the `SELECT` query is executed via the `query` remote function of the client by passing that \nresult set type. Once the query is executed, each data record can be retrieved by looping the result set. The `stream` \nreturned by the select operation holds a pointer to the actual data in the database and it loads data from the table \nonly when it is accessed. This stream can be iterated only once. \n\n```ballerina\n\/\/ Define a type to represent the results.\ntype Student record {\n    int id;\n    int age;\n    string name;\n};\n\n\/\/ Select the data from the database table. The query parameters are passed \n\/\/ directly. Similar to the `execute` examples, parameters can be passed as\n\/\/ sub types of `sql:TypedValue` as well.\nint id = 10;\nint age = 12;\nsql:ParameterizedQuery query = `SELECT * FROM students\n                                WHERE id < ${id} AND age > ${age}`;\nstream<Student, sql:Error> resultStream = \n        <stream<Student, sql:Error>> dbClient->query(query, Student);\n\n\/\/ Iterating the returned table.\nerror? e = resultStream.forEach(function(Student student) {\n   \/\/Can perform any operations using 'student' and can access any fields in the returned record of type Student.\n});\n```\n\nDefining the return type is optional and you can query the database without providing the result type. Hence, \nthe above example can be modified as follows with an open record type as the return type. The property name in the open record \ntype will be the same as how the column is defined in the database. \n\n```ballerina\n\/\/ Select the data from the database table. The query parameters are passed \n\/\/ directly. Similar to the `execute` examples, parameters can be passed as \n\/\/ sub types of `sql:TypedValue` as well.\nint id = 10;\nint age = 12;\nsql:ParameterizedQuery query = `SELECT * FROM students\n                                WHERE id < ${id} AND age > ${age}`;\nstream<record{}, sql:Error> resultStream = dbClient->query(query);\n\n\/\/ Iterating the returned table.\nerror? e = resultStream.forEach(function(record{} student) {\n    \/\/Can perform any operations using the 'student' and can access any fields in the returned record.\n});\n```\n\nThere are situations in which you may not want to iterate through the database and in that case, you may decide\nto only use the `next()` operation in the result `stream` and retrieve the first record. In such cases, the returned\nresult stream will not be closed, and you have to explicitly invoke the `close` operation on the \n`sql:Client` to release the connection resources and avoid a connection leak as shown below.\n\n```ballerina\nstream<record{}, sql:Error> resultStream = \n            dbClient->query(\"SELECT count(*) as total FROM students\");\n\nrecord {|record {} value;|}|error? result = resultStream.next();\n\nif result is record {|record {} value;|} {\n    \/\/ A valid result is returned.\n} else if result is error {\n    \/\/ An error is returned as the result.\n} else {\n    \/\/ Student table must be empty.\n}\n\nerror? e = resultStream.close();\n```\n\n#### Updating Data\n\nThis example demonstrates modifying data by executing an `UPDATE` statement via the `execute` remote function of \nthe client.\n\n```ballerina\nint age = 23;\nsql:ParameterizedQuery query = `UPDATE students SET name = 'John' \n                                WHERE age = ${age}`;\nsql:ExecutionResult|sql:Error ret = check dbClient->execute(query);\n```\n\n#### Deleting Data\n\nThis example demonstrates deleting data by executing a `DELETE` statement via the `execute` remote function of \nthe client.\n\n```ballerina\nstring name = \"John\";\nsql:ParameterizedQuery query = `DELETE from students WHERE name = ${name}`;\nsql:ExecutionResult|sql:Error ret = check dbClient->execute(query);\n```\n\n#### Batch Updating Data\n\nThis example demonstrates how to insert multiple records with a single `INSERT` statement that is executed via the \n`batchExecute` remote function of the client. This is done by creating a `table` with multiple records and \nparameterized SQL query as same as the above `execute` operations.\n\n```ballerina\n\/\/ Create the table with the records that need to be inserted.\nvar data = [\n  { name: \"John\", age: 25  },\n  { name: \"Peter\", age: 24 },\n  { name: \"jane\", age: 22 }\n];\n\n\/\/ Do the batch update by passing the batches.\nsql:ParameterizedQuery[] batch = from var row in data\n                                 select `INSERT INTO students ('name', 'age')\n                                 VALUES (${row.name}, ${row.age})`;\nsql:ExecutionResult[] ret = check dbClient->batchExecute(batch);\n```\n\n#### Execute SQL Stored Procedures\n\nThis example demonstrates how to execute a stored procedure with a single `INSERT` statement that is executed via the \n`call` remote function of the client.\n\n```ballerina\nint uid = 10;\nsql:IntegerOutParameter insertId = new;\n\nsql:ProcedureCallResult|sql:Error ret = dbClient->call(`call InsertPerson(${uid}, ${insertId})`);\nif ret is error {\n    \/\/An error returned.\n} else {\n    stream<record{}, sql:Error>? resultStr = ret.queryResult;\n    if resultStr is stream<record{}, sql:Error> {\n        sql:Error? e = resultStr.forEach(function(record{} result) {\n        \/\/can perform operations using 'result'.\n      });\n    }\n    check ret.close();\n}\n```\nNote that you have to invoke the close operation explicitly on the `sql:ProcedureCallResult` to release the connection resources and avoid a connection leak as shown above.\n\n>**Note:** The default thread pool size used in Ballerina is: [the number of processors available * 2] . You can configure\nthe thread pool size by using the `BALLERINA_MAX_POOL_SIZE` environment variable.", "apiDocURL":"https://docs.central.ballerina.io/ballerina/sql/0.6.0-beta.1", "packageUrl":"/ballerina/sql/0.6.0-beta.1"}], "pullCount":4}, {"organization":"ballerinax", "name":"rabbitmq", "version":"1.1.0-beta.1", "platform":"java11", "languageSpecificationVersion":"2021R1", "URL":"/ballerinax/rabbitmq/1.1.0-beta.1", "balaVersion":"2.0.0", "balaURL":"https://fileserver.central.ballerina.io/2.0/ballerinax/rabbitmq/1.1.0-beta.1/ballerinax-rabbitmq-java11-1.1.0-beta.1.bala", "digest":"sha-256=7dedd0fb5c4a63571e083663bd81083cbc2df5c1ee0c6e8a034a5368b6ce232a", "summary":"", "readme":"## Package Overview\n\nThe `rabbitmq` library is one of the standard library packages of the<a target=\"_blank\" href=\"https:\/\/ballerina.io\n\/\"> Ballerina <\/a> language.\n\nThis package provides the capability to send and receive messages by connecting to the RabbitMQ server. RabbitMQ gives your applications a common platform to send and receive messages and a safe place for your messages to live until received. RabbitMQ is one of the most popular open-source message brokers. It is lightweight and easy to deploy on-premise and in the cloud. \n\n### Report Issues\n\nTo report bugs, request new features, start new discussions, view project boards, etc., go to the [Ballerina Standard Library parent repository](https:\/\/github.com\/ballerina-platform\/ballerina-standard-library).\n\n### Useful Links\n\n- Discuss code changes of the Ballerina project in [ballerina-dev@googlegroups.com](mailto:ballerina-dev@googlegroups.com).\n- Chat live with us via our [Slack channel](https:\/\/ballerina.io\/community\/slack\/).\n- Post all technical questions on Stack Overflow with the [#ballerina](https:\/\/stackoverflow.com\/questions\/tagged\/ballerina) tag.", "template":false, "licenses":[], "authors":[], "sourceCodeLocation":"", "keywords":[], "ballerinaVersion":"slbeta1", "icon":"", "createdDate":1622648677000, "modules":[{"name":"rabbitmq", "summary":"", "readme":"## Overview\n\nThis module provides the capability to send and receive messages by connecting to the RabbitMQ server.\n\nRabbitMQ gives your applications a common platform to send and receive messages and a safe place for your messages to live until received. RabbitMQ is one of the most popular open-source message brokers. It is lightweight and easy to deploy on-premise and in the cloud.\n\n### Basic Usage\n\n#### Setting Up the Connection\n\nFirst, you need to set up the connection with the RabbitMQ server. The following ways can be used to connect to a\nRabbitMQ server.\n\n1. Connect to a RabbitMQ node with the default host and port:\n```ballerina\n    rabbitmq:Client rabbitmqClient = check new(rabbitmq:DEFAULT_HOST, rabbitmq:DEFAULT_PORT);\n```\n\n2. Connect to a RabbitMQ node with a custom host and port:\n```ballerina\n    rabbitmq:Client rabbitmqClient = check new(\"localhost\", 5672);\n```\n\n3. Connect to a RabbitMQ node with host, port, and additional configurations:\n```ballerina\n    rabbitmq:ConnectionConfiguration config = {\n        username: \"ballerina\",\n        password: \"password\"\n    };\n    rabbitmq:Client rabbitmqClient = check new(\"localhost\", 5672, configs);\n```\n\nThe `rabbitmq:Client` can now be used to send and receive messages as described in the subsequent sections.\n\n#### Using Exchanges and Queues\n\nClient applications work with exchanges and queues, which are the high-level building blocks of the AMQP protocol. These must be declared before they can be used. The following code declares an exchange and a server-named queue and then binds them together.\n\n```ballerina\n    check rabbitmqClient->exchangeDeclare(\"MyExchange\", rabbitmq:DIRECT_EXCHANGE);\n    check rabbitmqClient->queueDeclare(\"MyQueue\");\n    check rabbitmqClient->queueBind(\"MyQueue\", \"MyExchange\", \"routing-key\");\n```\n\nThis sample code will declare,\n- a durable auto-delete exchange of the type `rabbitmq:DIRECT_EXCHANGE`\n- a non-durable, exclusive auto-delete queue with an auto-generated name\n\nNext, the `queueBind` function is called to bind the queue to the exchange with the given routing key.\n\n```ballerina\n    check rabbitmqClient->exchangeDeclare(\"MyExchange\", rabbitmq:DIRECT_EXCHANGE);\n    check rabbitmqClient->queueDeclare(\"MyQueue\", { durable: true,\n                                                   exclusive: false,\n                                                   autoDelete: false });\n    check rabbitmqClient->queueBind(\"MyQueue\", \"MyExchange\", \"routing-key\");\n```\n\nThis sample code will declare,\n- a durable auto-delete exchange of the type `rabbitmq:DIRECT_EXCHANGE`\n- a durable, non-exclusive, non-auto-delete queue with a well-known name\n\n#### Deleting Entities and Purging Queues\n\n- Delete a queue:\n```ballerina\n    check rabbitmqClient->queueDelete(\"MyQueue\");\n```\n- Delete a queue only if it is empty:\n```ballerina\n    check rabbitmqClient->queueDelete(\"MyQueue\", false, true);\n```\n- Delete a queue only if it is unused (does not have any consumers):\n```ballerina\n    check rabbitmqClient->queueDelete(\"MyQueue\", true, false);\n```\n- Delete an exchange:\n```ballerina\n    check rabbitmqClient->exchangeDelete(\"MyExchange\");\n```\n- Purge a queue (delete all of its messages):\n```ballerina\n    check rabbitmqClient->queuePurge(\"MyQueue\");\n```\n\n#### Publishing Messages\n\nTo publish a message to an exchange, use the `publishMessage()` function as follows:\n\n```ballerina\n    string message = \"Hello from Ballerina\";\n    check rabbitmqClient->publishMessage({ content: message.toBytes(), routingKey: queueName });\n``` \nSetting other properties of the message such as routing headers can be done by using the `BasicProperties` record with the appropriate values.\n\n```ballerina\n    rabbitmq:BasicProperties props = {\n       replyTo: \"reply-queue\"  \n    };\n    string message = \"Hello from Ballerina\";\n    check rabbitmqClient->publishMessage({ content: message.toBytes(), routingKey: queueName, properties: props });\n```\n\n#### Consuming Messages using Consumer Services\n\nThe most efficient way to receive messages is to set up a subscription using a Ballerina RabbitMQ `rabbitmq:Listener` and any number of consumer services. The messages will then be delivered automatically as they arrive rather than having to be explicitly requested. Multiple consumer services can be bound to one Ballerina RabbitMQ `rabbitmq:Listener`. The queue to which the service is listening is configured in the `rabbitmq:ServiceConfig` annotation of the service or else as the name of the service.\n\n1. Listen to incoming messages with the `onMessage` remote method:\n\n```ballerina\n    listener rabbitmq:Listener channelListener= new(rabbitmq:DEFAULT_HOST, rabbitmq:DEFAULT_PORT);\n    \n    @rabbitmq:ServiceConfig {\n        queueName: \"MyQueue\"\n    }\n    service rabbitmq:Service on channelListener {\n        remote function onMessage(rabbitmq:Message message) {\n        }\n    }\n```\n\n2. Listen to incoming messages and reply directly with the `onRequest` remote method:\n\n```ballerina\n    listener rabbitmq:Listener channelListener= new(rabbitmq:DEFAULT_HOST, rabbitmq:DEFAULT_PORT);\n    \n    @rabbitmq:ServiceConfig {\n        queueName: \"MyQueue\"\n    }\n    service rabbitmq:Service on channelListener {\n        remote function onRequest(rabbitmq:Message message) returns string {\n            return \"Hello Back!\";\n        }\n    }\n```\n\nThe `rabbitmq:Message` record received can be used to retrieve its contents.\n\n### Advanced Usage\n\n#### Client Acknowledgements\n\nThe message consuming is supported by mainly two types of acknowledgement modes, which are auto acknowledgements and client acknowledgements.\nClient acknowledgements can further be divided into two different types as positive and negative acknowledgements.\nThe default acknowledgement mode is auto-ack (messages are acknowledged immediately after consuming). The following examples show the usage of positive and negative acknowledgements.\n> WARNING: To ensure the reliability of receiving messages, use the client-ack mode.\n\n1. Positive client acknowledgement:\n```ballerina\n    listener rabbitmq:Listener channelListener= new(rabbitmq:DEFAULT_HOST, rabbitmq:DEFAULT_PORT);\n    \n    @rabbitmq:ServiceConfig {\n        queueName: \"MyQueue\",\n        autoAck: false\n    }\n    service rabbitmq:Service on channelListener {\n        remote function onMessage(rabbitmq:Message message, rabbitmq:Caller caller) {\n            rabbitmq:Error? result = caller->basicAck();\n        }\n    }\n```\n\n2. Negative client acknowledgement:\n```ballerina\n    listener rabbitmq:Listener channelListener= new(rabbitmq:DEFAULT_HOST, rabbitmq:DEFAULT_PORT);\n    \n    @rabbitmq:ServiceConfig {\n        queueName: \"MyQueue\",\n        autoAck: false\n    }\n    service rabbitmq:Service on channelListener {\n        remote function onMessage(rabbitmq:Message message) {\n            rabbitmq:Error? result = caller->basicNack(true, requeue = false);\n        }\n    }\n```\n\nThe negatively-acknowledged (rejected) messages can be re-queued by setting the `requeue` to `true`.", "apiDocURL":"https://docs.central.ballerina.io/ballerinax/rabbitmq/1.1.0-beta.1", "packageUrl":"/ballerinax/rabbitmq/1.1.0-beta.1"}], "pullCount":5}, {"organization":"ballerinax", "name":"kafka", "version":"2.1.0-beta.1", "platform":"java11", "languageSpecificationVersion":"2021R1", "URL":"/ballerinax/kafka/2.1.0-beta.1", "balaVersion":"2.0.0", "balaURL":"https://fileserver.central.ballerina.io/2.0/ballerinax/kafka/2.1.0-beta.1/ballerinax-kafka-java11-2.1.0-beta.1.bala", "digest":"sha-256=7159ab5a705431b87b813b41b883ad49eba67c8686520ddb7fb630f745703590", "summary":"", "readme":"## Overview\n\nThe `kafka` package is one of the standard library packages of the <a target=\"_blank\" href=\"https:\/\/ballerina.io \/\"> Ballerina<\/a> language.\n\nThis package provides support for the Apache Kafka event streaming platform. This helps to communicate with Kafka brokers as Producers and Consumers. Apache Kafka is an open-source distributed event streaming platform used for high-performance data pipelines, streaming analytics, data integration, and mission-critical applications.  \n\n### Report Issues\n\nTo report bugs, request new features, start new discussions, view project boards, etc., go to the [Ballerina\nStandard Library parent repository](https:\/\/github.com\/ballerina-platform\/ballerina-standard-library).\n\n### Useful Links\n\n- Discuss about code changes of the Ballerina project in [ballerina-dev@googlegroups.com](mailto:ballerina-dev@googlegroups.com).\n- Chat live with us via our [Slack channel](https:\/\/ballerina.io\/community\/slack\/).\n- Post all technical questions on Stack Overflow with the [#ballerina](https:\/\/stackoverflow.com\/questions\/tagged\/ballerina) tag.", "template":false, "licenses":[], "authors":[], "sourceCodeLocation":"", "keywords":[], "ballerinaVersion":"slbeta1", "icon":"", "createdDate":1622648489000, "modules":[{"name":"kafka", "summary":"", "readme":"## Overview\n\nThis module provides an implementation to interact with Kafka Brokers via Kafka Consumer and Kafka Producer clients.\n\nApache Kafka is an open-source distributed event streaming platform used for high-performance data pipelines, streaming analytics, data integration, and mission-critical applications.\n\nThis module supports Kafka 1.x.x and 2.0.0 versions.\n\n### Consumer and Producer\n#### Kafka Producer\nA Kafka producer is a Kafka client that publishes records to the Kafka cluster. The producer is thread-safe and sharing a single producer instance across threads will generally be faster than having multiple instances. When working with a Kafka producer, the first thing to do is to initialize the producer.\nFor the producer to execute successfully, an active Kafka broker should be available.\n\nThe code snippet given below initializes a producer with the basic configuration.\n```ballerina\nimport ballerinax\/kafka;\n\nkafka:ProducerConfiguration producerConfiguration = {\n    clientId: \"basic-producer\",\n    acks: \"all\",\n    retryCount: 3\n};\n\nkafka:Producer kafkaProducer = check new (kafka:DEFAULT_URL, producerConfiguration);\n```\n#### Kafka Consumer\nA Kafka consumer is a subscriber responsible for reading records from one or more topics and one or more partitions of a topic. When working with a Kafka consumer, the first thing to do is initialize the consumer.\nFor the consumer to execute successfully, an active Kafka broker should be available.\n\nThe code snippet given below initializes a consumer with the basic configuration.\n```ballerina\nkafka:ConsumerConfiguration consumerConfiguration = {\n    groupId: \"group-id\",    \/\/ Unique string that identifies the consumer\n    offsetReset: \"earliest\",    \/\/ Offset reset strategy if no initial offset\n    topics: [\"kafka-topic\"]\n};\n\nkafka:Consumer kafkaConsumer = check new (kafka:DEFAULT_URL, consumerConfiguration);\n```\n### Listener\nThe Kafka consumer can be used as a listener to a set of topics without the need to manually `poll` the messages.\n\nYou can use the `Caller` to manually commit the offsets of the messages that are read by the service. The following code snippet shows how to initialize and define the listener and how to commit the offsets manually.\n```ballerina\nkafka:ConsumerConfiguration consumerConfigs = {\n    groupId: \"group-id\",\n    topics: [\"kafka-topic-1\"],\n    pollingInterval: 1,\n    autoCommit: false\n};\n\nlistener kafka:Listener kafkaListener = new (kafka:DEFAULT_URL, consumerConfiguration);\n\nservice kafka:Service on kafkaListener {\n    remote function onConsumerRecord(kafka:Caller caller, kafka:ConsumerRecord[] records) {\n        \/\/ processes the records\n        ...\n        \/\/ commits the offsets manually\n        kafka:Error? commitResult = caller->commit();\n\n        if (commitResult is error) {\n            io:println(\"Error occurred while committing the offsets for the consumer \", 'error = commitResult);\n        }\n    }\n}\n```\n### Data Serialization\nSerialization is the process of converting data into a stream of bytes that is used for transmission. Kafka\nstores and transmits these bytes of arrays in its queue. Deserialization does the opposite of serialization\nin which bytes of arrays are converted into the desired data type.\n\nCurrently, this module only supports the `byte array` data type for both the keys and values. The following code snippets\nshow how to produce and read a message from Kafka.\n```ballerina\nstring message = \"Hello World, Ballerina\";\nstring key = \"my-key\";\n\/\/ converts the message and key to a byte array\ncheck kafkaProducer->send({ topic: \"test-kafka-topic\", key: key.toBytes(), value: message.toBytes() });\n```\n```ballerina\nkafka:ConsumerRecord[] records = check kafkaConsumer->poll(1);\n\nforeach var kafkaRecord in records {\n    byte[] messageContent = kafkaRecord.value;\n    \/\/ tries to generate the string value from the byte array\n    string result = check string:fromBytes(messageContent);\n    io:println(\"The result is : \", result);\n}\n```\n### Concurrency\nIn Kafka, records are grouped into smaller units called partitions. These can be processed independently without\ncompromising the correctness of the results and lays the foundation for parallel processing. This can be achieved by\nusing multiple consumers within the same group each reading and processing data from a subset of topic partitions and \nrunning in a single thread.\n\nTopic partitions are assigned to consumers automatically or you can manually assign topic partitions.\n\nThe following code snippet joins a consumer to the `consumer-group` and assigns it to a topic partition manually.\n```ballerina\nkafka:ConsumerConfiguration consumerConfigs = {\n    \/\/ `groupId` determines the consumer group\n    groupId: \"consumer-group\",\n    pollingInterval: 1,\n    autoCommit: false\n};\n\nkafka:Consumer kafkaConsumer = check new (kafka:DEFAULT_URL, consumerConfiguration);\n\/\/ creates a topic partition\nkafka:TopicPartition topicPartition = {\n    topic: \"kafka-topic-1\",\n    partition: 1\n};\n\/\/ passes the topic partitions to the assign function as an array\ncheck kafkaConsumer->assign([topicPartition]);\n```", "apiDocURL":"https://docs.central.ballerina.io/ballerinax/kafka/2.1.0-beta.1", "packageUrl":"/ballerinax/kafka/2.1.0-beta.1"}], "pullCount":10}, {"organization":"hevayo", "name":"myyaml", "version":"0.2.0", "platform":"java11", "languageSpecificationVersion":"2021R1", "URL":"/hevayo/myyaml/0.2.0", "balaVersion":"2.0.0", "balaURL":"https://fileserver.central.ballerina.io/2.0/hevayo/myyaml/0.2.0/hevayo-myyaml-java11-0.2.0.bala", "digest":"sha-256=37d05a350267d7edc88c137347a231963b229b4a6774a7e76432f23f0562e695", "summary":"Prints \"Hello World!\" with a hello function.", "readme":"Prints \"Hello World!\" with a hello function.\n\n# Package Overview\nPrints \"Hello World!\" as the output to the command line using a hello function.", "template":false, "licenses":[], "authors":[], "sourceCodeLocation":"", "keywords":[], "ballerinaVersion":"slbeta1", "icon":"", "createdDate":1622647006000, "modules":[{"name":"myyaml", "summary":"", "readme":"", "apiDocURL":"https://docs.central.ballerina.io/hevayo/myyaml/0.2.0", "packageUrl":"/hevayo/myyaml/0.2.0"}], "pullCount":4}, {"organization":"ballerina", "name":"websocket", "version":"1.2.0-beta.1", "platform":"java11", "languageSpecificationVersion":"2021R1", "URL":"/ballerina/websocket/1.2.0-beta.1", "balaVersion":"2.0.0", "balaURL":"https://fileserver.central.ballerina.io/2.0/ballerina/websocket/1.2.0-beta.1/ballerina-websocket-java11-1.2.0-beta.1.bala", "digest":"sha-256=292b535c6e678c335d593cf701e5b10c71d99e70bfab8c7202f162b92c97f55c", "summary":"", "readme":"## Package Overview\n\nThe `websocket` library is one of the standard library packages of the<a target=\"_blank\" href=\"https:\/\/ballerina.io\/\"> Ballerina <\/a> language.\n\nThis package provides support for the WebSocket protocol. The WebSocket is a protocol, which provides bidirectional, full-duplex communication channels over a single TCP connection. \n\n### Report Issues\n\nTo report bugs, request new features, start new discussions, view project boards, etc., go to the [Ballerina Standard Library parent repository](https:\/\/github.com\/ballerina-platform\/ballerina-standard-library).\n\n### Useful Links\n\n- Discuss about code changes of the Ballerina project in [ballerina-dev@googlegroups.com](mailto:ballerina-dev@googlegroups.com).\n- Chat live with us via our [Slack channel](https:\/\/ballerina.io\/community\/slack\/).\n- Post all technical questions on Stack Overflow with the [#ballerina](https:\/\/stackoverflow.com\/questions\/tagged\/ballerina) tag.", "template":false, "licenses":[], "authors":[], "sourceCodeLocation":"", "keywords":[], "ballerinaVersion":"slbeta1", "icon":"", "createdDate":1622631218000, "modules":[{"name":"websocket", "summary":"", "readme":"## Overview\n\nThis module provides APIs for connecting and interacting with WebSocket endpoints. \n\nThis module facilitates two types of network entry points as the ‘Client’ and ‘Listener’. \n\n#### Client\n\nThe `websocket:Client` can be used to read\/write text\/binary messages synchronously. \n\nA simple client code to handle text messages as follows.\n```ballerina\nimport ballerina\/websocket;\n\npublic function main() returns error? {\n   websocket:Client wsClient = check new(\"ws:\/\/echo.websocket.org\");\n\n   check wsClient->writeTextMessage(\"Text message\");\n\n   string textResp = check wsClient->readTextMessage();\n}\n```\nSimilar to the above, this module has the `writeBinaryMessage` and `readBinaryMessage` functions to handle binary messages.\nA callback service with the two `onPing` and `onPong` remote functions can be registered at the initialization of the client to receive the `ping\/pong` control frames.\n```ballerina\nimport ballerina\/io;\nimport ballerina\/websocket;\n\npublic function main() returns error? {\n   websocket:Client wsClient = check new(\"ws:\/\/echo.websocket.org\", pingPongHandler = new clientPingPongCallbackService());\n   check wsClient->writeTextMessage(\"Text message\");\n}\n\nservice class clientPingPongCallbackService {\n    *websocket:PingPongService;\n    remote isolated function onPing(websocket:Caller caller, byte[] localData) returns byte[] {\n        io:println(\"Ping message received\");\n        return localData;\n    }\n\n    remote isolated function onPong(websocket:Caller caller, byte[] localData) {\n        io:println(\"Pong message received\");\n    }\n}\n```\n\n#### Listener\n\nOn the listener-side, an initial WebSocket upgrade service can be attached to the `websocket:Listener` to handle upgrade requests. It has a single `get` resource, which takes in an `http:Request` optionally. The `get` resource returns a `websocket:Service` to which incoming messages get dispatched after a successful WebSocket connection upgrade. This resource can be used to intercept the initial HTTP upgrade with custom headers or to cancel the WebSocket upgrade by returning an error.\nThe returning `websocket:Service` has a fixed set of remote methods.\n\n```ballerina\nservice \/ws on new websocket:Listener(21003) {\n    resource function get .(http:Request req) returns websocket:Service|websocket:UpgradeError {\n        return new WsService();\n}\n        \nservice class WsService {\n  *websocket:Service;\n  remote isolated function onTextMessage(websocket:Caller caller, string data) returns websocket:Error? {\n      check caller->writeTextMessage(data);\n  }\n}              \n```\n\n##### Remote methods associated with `websocket:Service`\n\n**onOpen**: As soon as the WebSocket handshake is completed and the connection is established, the `onOpen` remote method is dispatched.\n\n**onTextMessage**: The received text messages are dispatched to this remote method.\n\n**onBinaryMessage**: The received binary messages are dispatched to this remote method.\n\n**onPing and onPong**: The received ping and pong messages are dispatched to these remote methods respectively.\n\n**onIdleTimeout**: This remote method is dispatched when the idle timeout is reached. The `idleTimeout` has to be configured either in the WebSocket service or the client configuration.\n\n**onClose**: This remote method is dispatched when a close frame with a `statusCode` and a reason is received.\n\n**onError**: This remote method is dispatched when an error occurs in the WebSocket connection. This will always be preceded by a connection closure with an appropriate close frame.\n\n#### Control Messages\n\nA WebSocket contains three types of control messages: `close`, `ping`, and `pong`. A WebSocket server or a client can send a `ping` message and the opposite side should respond with a corresponding `pong` message by returning the same payload sent with the `ping` message. These ping\/pong sequences are used as a heartbeat mechanism to check if the connection is healthy. \n\nYou do not need to explicitly control these messages as they are handled automatically by the services and clients. However, if required, you can override the default implementations of the ping\/pong messages by registering a `websocket:PingPongService` in the client side as given in the above client code sample and by including the `onPing` and `onPong` remote functions in the `websocket:Service` in the server side.\n\n```ballerina\nremote function onPing(websocket:Caller caller, byte[] data) returns error? {\n    io:println(string `Ping received with data: ${data.toBase64()}`);\n    check caller->pong(data);\n}\n \nremote function onPong(websocket:Caller caller, byte[] data) {\n    io:println(string `Pong received with data: ${data.toBase64()}`);\n}\n```\n\nA WebSocket server or a client can close the WebSocket connection by calling the `close` function. In the event of a connection closure, the service will be notified by invoking the `onClose` remote function. Also, on the client side, you will get a connection closure error if you try to read\/write messages.\n\n```ballerina\nremote function onClose(websocket:Caller caller, int statusCode, string reason) {\n    io:println(string `Client closed connection with ${statusCode} because of ${reason}`);\n}\n```\n\n#### WebSocket Compression\n\nPer message compression extensions are supported by the Ballerina `websocket` module and this is enabled by default for both the WebSocket client and the server. Compression can be enabled or disabled by setting the `webSocketCompressionEnabled` to `true` or `false` in the `ClientConfiguration` and `ListenerConfiguration`. Once the compression is successfully negotiated, receiving compressed messages will be automatically decompressed when reading.\n\n#### Origin Considerations\n\nThe `Origin` header can be used to differentiate between WebSocket connections from different hosts or between those made from a browser and some other kind of network client. It is recommended to validate this `Origin` header before accepting the WebSocket upgrade.\n```ballerina\nimport ballerina\/http;\nimport ballerina\/websocket;\n\nservice \/basic\/ws on new websocket:Listener(9090) {\n   resource isolated function get .(http:Request httpRequest) returns websocket:Service|websocket:UpgradeError {\n       string|error header = httpRequest.getHeader(\"Origin\");\n       if header is string {\n           \/\/ Implement validateOrigin function to validate the origin header.\n\t       boolean validated = validateOrigin(header);\n           if validated {\n              return new WsService();\n           }\n       }\n       return error(\"Invalid upgrade request\");\n   }\n}\nservice class WsService {\n    *websocket:Service;\n    remote function onTextMessage(websocket:Caller caller, string text) {\n        \n    }\n}\n```\n\n#### Using the TLS protocol to secure WebSocket communication\n\nIt is strongly recommended to use the `wss:\/\/` protocol to protect against man-in-the-middle attacks. The Ballerina `websocket` module allows the use of TLS in communication to do this. This expects a secure socket to be set in the connection configuration as shown below.\n\n##### Configuring TLS in server side\n\n```ballerina\nlistener websocket:Listener wssListener = new (9090, {\n    secureSocket: {\n        key: {\n            certFile: \"..\/resource\/path\/to\/public.crt\",\n            keyFile: \"..\/resource\/path\/to\/private.key\"\n        }\n    }\n});\nservice \/basic\/ws on wssListener {\n    \n}\n```\n\n##### Configuring TLS in client side\n\n```ballerina\nwebsocket:Client wssClient = new (\"wss:\/\/echo.websocket.org\", {\n    secureSocket: {\n        cert: \"..\/resource\/path\/to\/public.crt\"\n    }\n});\n```", "apiDocURL":"https://docs.central.ballerina.io/ballerina/websocket/1.2.0-beta.1", "packageUrl":"/ballerina/websocket/1.2.0-beta.1"}], "pullCount":6}, {"organization":"ballerina", "name":"grpc", "version":"0.8.0-beta.1", "platform":"java11", "languageSpecificationVersion":"2021R1", "URL":"/ballerina/grpc/0.8.0-beta.1", "balaVersion":"2.0.0", "balaURL":"https://fileserver.central.ballerina.io/2.0/ballerina/grpc/0.8.0-beta.1/ballerina-grpc-java11-0.8.0-beta.1.bala", "digest":"sha-256=701456bd6c0f8fbe9f25acb0fbf912924bcd8f702e0d477d8f17a428938616e0", "summary":"", "readme":"## Package Overview\n\nThe `grpc` library is one of the standard library packages of the<a target=\"_blank\" href=\"https:\/\/ballerina.io\n\/\"> Ballerina <\/a> language.\n\nThis package provides support for the gRPC messaging protocol. gRPC is an inter-process communication technology\n that allows you to connect, invoke, and operate distributed, heterogeneous applications as easily as making a local function call. The gRPC protocol is layered over HTTP\/2 and uses Protocol Buffers for marshaling\/unmarshaling messages. This makes gRPC highly efficient on wire and a simple service definition framework.\n\n### Report Issues\n\nTo report bugs, request new features, start new discussions, view project boards, etc., go to the [Ballerina Standard Library parent repository](https:\/\/github.com\/ballerina-platform\/ballerina-standard-library).\n\n### Useful Links\n\n- Discuss code changes of the Ballerina project in [ballerina-dev@googlegroups.com](mailto:ballerina-dev@googlegroups.com).\n- Chat live with us via our [Slack channel](https:\/\/ballerina.io\/community\/slack\/).\n- Post all technical questions on Stack Overflow with the [#ballerina](https:\/\/stackoverflow.com\/questions\/tagged\/ballerina) tag.", "template":false, "licenses":[], "authors":[], "sourceCodeLocation":"", "keywords":[], "ballerinaVersion":"slbeta1", "icon":"", "createdDate":1622631193000, "modules":[{"name":"grpc", "summary":"", "readme":"## Overview\n\nThis module provides APIs for connecting and interacting with gRPC endpoints. \n\ngRPC is an inter-process communication technology that allows you to connect, invoke, and operate distributed, heterogeneous applications as easily as making a local function call. The gRPC protocol is layered over HTTP\/2 and uses Protocol Buffers for marshaling\/unmarshaling messages. This makes gRPC highly efficient on wire and a simple service definition framework.\n\nWhen you develop a gRPC application, the first thing you do is define a service definition using Protocol Buffers.\n\n### Protocol Buffers\nThis is a mechanism to serialize the structured data introduced by Google and used by the gRPC framework. Defining the service using Protocol Buffers includes defining remote methods in the service and defining message types that are sent across the network. A sample service definition is shown below.\n\n```proto\nsyntax = \"proto3\";\n\nservice Helloworld {\n    rpc hello(HelloRequest) returns (HelloResponse);\n}\n\nmessage HelloRequest {\n    string name = 1;\n}\n\nmessage HelloResponse {\n    string message = 1;\n}\n```\n\ngRPC allows client applications to directly call the server-side methods using the auto-generated stubs. Protocol\n Buffer compiler is used to generate the stubs for the specified language. In Ballerina, the stubs are generated using the built-in 'Protocol Buffers to Ballerina' tool. \n\nFor information on how to generate Ballerina code for Protocol Buffers definition, see [gRPC](https:\/\/ballerina.io\/learn\/user-guide\/network-communication\/grpc\/).\n\n### gRPC Communication Patterns\nThe common communication pattern between a client and server is simple request-response style communication. However, with gRPC, you can leverage different inter-process communication patterns other than the simple request-response pattern.\nThis module supports four fundamental communication patterns used in gRPC-based applications: simple RPC(unary RPC), server streaming RPC, client streaming RPC, and bidirectional streaming RPC.\n\n#### Simple RPC (Unary RPC) \nIn this pattern, the client invokes a remote function of a server and sends a single request to the server. The server sends a single response in return to the client along with status details.\n\n```proto\nservice HelloWorld {\n    rpc hello (google.protobuf.StringValue)\n          returns (google.protobuf.StringValue);\n}\n```\n##### Creating the Server\nThe code snippet given below contains a service that sends a response to each request.\n\n```ballerina\n\/\/ The gRPC service is attached to the listener.\nservice HelloWorld on new grpc:Listener(9090)  {\n    \/\/ The function accepts a string message.\n    remote function hello(string name) returns string|error {\n        \/\/ Send the response to the client.\n        return \"Hi \" + name + \"! Greetings from gRPC service!\");\n    }\n}\n```\n##### Creating the Client\nThe code snippet given below calls the above service in a synchronized manner using an auto-generated Ballerina stub.\n\n```ballerina\n\/\/ Use ‘HelloWorldClient’ to execute the call in the synchronized mode.\nHelloWorldClient helloClient = check new(\"http:\/\/localhost:9090\");\n\n\/\/ Call the service remote function using a client stub.\nstring responseFromServer = check helloClient->hello(\"Ballerina\");\n```\n\n#### Server streaming RPC\nIn server-side streaming RPC, the server sends back a sequence of responses after getting the client's request message. After sending all the server responses, the server marks the end of the stream by sending the server status details.\nYou can invoke this in a non-blocking manner.\n\n```proto\nservice HelloWorld {\n    rpc lotsOfReplies (google.protobuf.StringValue)\n          returns (stream google.protobuf.StringValue);\n}\n```\n##### Creating the Server\nThe code snippet given below contains a service that sends a sequence of responses to each request.\n\n```ballerina\n\/\/ The gRPC service is attached to the listener.\nservice HelloWorld on new grpc:Listener(9090) {\n    remote function lotsOfReplies(string name) returns stream<string, grpc:Error?> {\n        string[] greets = [\"Hi \" + name, \"Welcome \" + name];\n        \/\/ Send multiple responses to the client.\n        return greets.toStream();\n   }\n}\n```\n\n##### Creating the Client\nThe code snippet given below calls the above service using the auto-generated Ballerina client stub and reads multiple server responses using a stream.\nHere, the message stream is ended with a `()` value.\n\n```ballerina\n   \/\/ Client endpoint configurations.\n    HelloWorldClient helloworldClient = check new(\"http:\/\/localhost:9090\");\n\n    \/\/ Execute the service streaming call by registering a message listener.\n    stream<string, grpc:Error?> result = \n                                check helloworldClient->lotsOfReplies(\"Ballerina\");\n```\n\n#### Client streaming RPC\nIn client streaming RPC, the client sends multiple messages to the server instead of a single request. The server sends back a single response to the client.\n\n```proto\nservice HelloWorld {\n    rpc lotsOfGreetings (stream google.protobuf.StringValue)\n          returns (google.protobuf.StringValue);\n}\n```\n\n##### Creating the Server\nThe code snippet given below contains a service that receives a sequence of requests from the client and sends a single response in return.\n\n```ballerina\n\/\/ The gRPC service is attached to the listener.\nservice HelloWorld on new grpc:Listener(9090) {\n\n    \/\/ This function is triggered when a new client connection is initialized.\n    remote function lotsOfGreetings(stream<string, grpc:Error?> clientStream) \n                                                        returns string|error {\n        \/\/ Iterate through the client stream\n        check clientStream.forEach(function(string name) {\n            \/\/ Handle the message sent from the stream here\n        });\n        \/\/ A nil value is returned once the client stream is ended\n        \/\/ Return server response to the client.\n        return \"Ack\";\n    }\n}\n```\n\n##### Creating the Client\nThe code snippet given below calls the above service using the auto-generated Ballerina client stub and sends multiple request messages from the server.\n\n```ballerina\n    \/\/ Client endpoint configurations.\n    HelloWorldClient helloworldClient = check new(\"http:\/\/localhost:9090\");\n\n    \/\/ Execute the service streaming call by registering a message listener.\n    LotsOfGreetingsStreamingClient streamingClient = \n                                        check helloworldClient->lotsOfGreetings();\n\n    \/\/ Send multiple messages to the server.\n    string[] greets = [\"Hi\", \"Hey\", \"GM\"];\n    foreach string greet in greets {\n        grpc:Error? connErr = streamingClient->sendstring(greet + \" \" + \"Ballerina\");\n    }\n\n    \/\/ Once all the messages are sent, the client notifies the server \n    \/\/ by closing the stream.\n    grpc:Error? result = streamingClient->complete();\n    \/\/ Receive the message from the server.\n    string|grpc:Error response = streamingClient->receiveString();\n...\n```\n\n#### Bidirectional Streaming RPC\nIn bidirectional streaming RPC, the client is sending a request to the server as a stream of messages. The server also responds with a stream of messages.\n\n```proto\nservice Chat {\n    rpc chat (stream ChatMessage)\n          returns (stream google.protobuf.StringValue);\n}\n```\n##### Creating the Server\nThe code snippet given below includes a service that handles bidirectional streaming.\n\n```ballerina\n\/\/ The gRPC service is attached to the listener.\nservice Chat on new grpc:Listener(9090) {\n\n    \/\/This `resource` is triggered when a new caller connection is initialized.\n    remote function chat(ChatStringCaller caller, \n                                    stream<ChatMessage, grpc:Error?> clientStream) {\n        \/\/Iterate through the client stream\n        check clientStream.forEach(function(ChatMessage chatMsg) {\n            \/\/ Handle the streamed messages sent from the client here\n            grpc:Error? err = caller->sendString(\n                                    string `${chatMsg.name}: ${chatMsg.message}`);\n        });\n        \/\/ A nil value is returned once the client stream is ended\n        \/\/ Handle once the client has completed streaming\n        caller->complete();\n    }\n}\n```\n##### Creating the Client\nThe code snippet given below calls the above service using the auto-generated Ballerina client stub and sends multiple request messages to the server and receives multiple responses from the server.\n\n```ballerina\n    \/\/ Client endpoint configurations.\n    ChatClient chatClient = check new(\"http:\/\/localhost:9090\");\n\n    \/\/ Execute the service streaming call by registering a message listener.\n    ChatStreamingClient streamingClient = check chatClient->chat();\n\n    \/\/ Send multiple messages to the server.\n    string[] greets = [\"Hi\", \"Hey\", \"GM\"];\n    foreach string greet in greets {\n        ChatMessage mes = {name: \"Ballerina\", message: greet};\n        grpc:Error? connErr = streamingClient->sendChatMessage(mes);\n    }\n\n    \/\/ Once all the messages are sent, the server notifies the caller \n    \/\/ with a `complete` message.\n    grpc:Error? result = streamingClient->complete();\n    ...\n\n    \/\/ Receive the server stream response iteratively.\n    string? result = check streamingClient->receiveString();\n    while !(result is ()) {\n        io:println(result);\n        result = streamingClient->receiveString();\n    }\n```\n\n### Advanced Use cases\n\n#### Using the TLS protocol\n\nThe Ballerina gRPC module allows the use of TLS in communication. This setting expects a secure socket to be \nset in the connection configuration as shown below.\n\n##### Configuring TLS in Server Side\n\n```ballerina\n\/\/ Server endpoint configuration with the SSL configurations.\nlistener grpc:Listener ep = new (9090, {\n    host: \"localhost\",\n    secureSocket: {\n        key: {\n            certFile: \"..\/resource\/path\/to\/public.crt\",\n            keyFile: \"..\/resource\/path\/to\/private.key\"\n        }\n    }\n});\n\nservice HelloWorld on ep {\n    \n}\n```\n\n##### Configuring TLS in Client Side\n\n```ballerina\n    \/\/ Client endpoint configuration with SSL configurations.\n    HelloWorldClient helloWorldClient = check new (\"https:\/\/localhost:9090\", {\n        secureSocket: {\n            cert: \"..\/resource\/path\/to\/public.crt\"\n        }\n    });\n```\n\n#### Using Headers\n\nThe Ballerina gRPC module allows to send\/receive headers with the request and response using the context record type. The\n context record type consists of two fields called headers and content. E.g: For the string message, a type generated context record type will be as follows.\n  \n```ballerina\npublic type ContextString record {|\n    string content;\n    map<string|string[]> headers;\n|};\n```\n\n##### Using Headers in the Client Side\n\n```ballerina\n    \/\/ Set the custom headers to the request.\n    ContextString requestMessage =\n    {content: \"WSO2\", headers: {client_header_key: \"0987654321\"}};\n    \/\/ Execute the remote call.\n    ContextString result = check ep->helloContext(requestMessage);\n    \/\/ Read Response content.\n    string content = result.content;\n    \/\/ Read Response header value.\n    string headerValue = check grpc:getHeader(result.headers, \n                                                    \"server_header_key\");\n```\n\n##### Using Headers in the Server Side\n\n```ballerina\nservice \"HelloWorld\" on new grpc:Listener(9090) {\n    remote function hello(ContextString request) returns ContextString|error {\n        \/\/ Read the request content.\n        string message = \"Hello \" + request.content;\n\n        \/\/ Read custom headers in request message.\n        string reqHeader = check grpc:getHeader(request.headers, \n                                                        \"client_header_key\");\n\n        \/\/ Send response with custom headers.\n        return {content: message, \n                        headers: {server_header_key: \"Response Header value\"}};\n    }\n}\n```\n\n#### Using Deadlines\n\nDeadlines allow gRPC clients to specify how long they are willing to wait for an RPC to complete before the RPC is\n terminated with the `DEADLINE_EXCEEDED` error. In Ballerina, a deadline value is set directly to the headers and it is sent\n  via the request headers.\n\n##### Setting a Deadline in the Request Headers\n\n```ballerina\n    time:Utc current = time:utcNow();\n    time:Utc deadline = time:utcAddSeconds(current, 300);\n    map<string|string[]> headers = grpc:setDeadline(deadline);\n```\n\n##### Checking the Deadlines\n\n```ballerina\n    boolean cancel = check grpc:isCancelled(request.headers);\n    if (cancel) {\n        return error DeadlineExceededError(\"Deadline exceeded\");\n    }\n```", "apiDocURL":"https://docs.central.ballerina.io/ballerina/grpc/0.8.0-beta.1", "packageUrl":"/ballerina/grpc/0.8.0-beta.1"}], "pullCount":4}, {"organization":"ballerina", "name":"websubhub", "version":"0.2.0-beta.1", "platform":"java11", "languageSpecificationVersion":"2021R1", "URL":"/ballerina/websubhub/0.2.0-beta.1", "balaVersion":"2.0.0", "balaURL":"https://fileserver.central.ballerina.io/2.0/ballerina/websubhub/0.2.0-beta.1/ballerina-websubhub-java11-0.2.0-beta.1.bala", "digest":"sha-256=6aa42c35eaa9c055f752a8122a50a60b2bce08ad388db841dd3f88c734e53eed", "summary":"", "readme":"## Package Overview\n\nThe `websubhub` package is one of the standard library packages of the <a target=\"_blank\" href=\"https:\/\/ballerina.io\/\">Ballerina<\/a> language.\n\nThis package provides the capability to easily implement a WebSub compliant **Hub Service** and **Publisher Client**.\n\n## Report Issues\n\nTo report bugs, request new features, start new discussions, view project boards, etc., go to the [Ballerina Standard Library parent repository](https:\/\/github.com\/ballerina-platform\/ballerina-standard-library).\n\n## Useful Links\n\n* Discuss code changes of the Ballerina project in [ballerina-dev@googlegroups.com](mailto:ballerina-dev@googlegroups.com).\n* Chat live with us via our [Slack channel](https:\/\/ballerina.io\/community\/slack\/).\n* Post all technical questions on Stack Overflow with the [#ballerina](https:\/\/stackoverflow.com\/questions\/tagged\/ballerina) tag.", "template":false, "licenses":[], "authors":[], "sourceCodeLocation":"", "keywords":[], "ballerinaVersion":"slbeta1", "icon":"", "createdDate":1622631163000, "modules":[{"name":"websubhub", "summary":"", "readme":"## Overview\n\nThis module provides APIs for WebSub Hub service and WebSub Publisher client.\n\n[**WebSub**](https:\/\/www.w3.org\/TR\/websub\/) is a common mechanism for communication between publishers of any kind of web content and their subscribers based on HTTP webhooks. Subscription requests are relayed through hubs, which validate and verify the requests. Hubs then distribute new and updated content to subscribers when it becomes available. WebSub was previously known as PubSubHubbub.\n\n[**WebSub Hub**](https:\/\/www.w3.org\/TR\/websub\/#hub) is an implementation that handles subscription requests and distributes the content to subscribers when the corresponding topic URL has been updated.\n\n[**WebSub Publisher**](https:\/\/www.w3.org\/TR\/websub\/#publisher) is an implementation that advertises a topic and hub URL on one or more resource URLs.\n\n### Basic flow with WebSub\n\n1. The subscriber discovers (from the publisher) the topic it needs to subscribe to and the hub(s) that deliver notifications on the updates of the topic.\n\n2. The subscriber sends a subscription request to one or more discovered hub(s) specifying the discovered topic along \n with other subscription parameters such as:\n    - The callback URL to which the content is expected to be delivered.\n    - (Optional) The lease period (in seconds) the subscriber wants the subscription to stay active.\n    - (Optional) A secret to use for [authenticated content distribution](https:\/\/www.w3.org\/TR\/websub\/#signing-content).\n  \n3. The hub sends an intent verification request to the specified callback URL. If the response indicates\nverification (by echoing a challenge specified in the request) by the subscriber, the subscription is added for the topic at the hub.\n\n4. The publisher notifies the hub of the updates to the topic and the content to deliver is identified.\n\n5. The hub delivers the identified content to the subscribers of the topic.\n\n#### Using Hub Client\n\n* **WebSub HubClient** can be used to distribute the published content among the `subscriber base`. The current implementation is based on\na `ballerina HTTP Client`.\n\n```ballerina\n    client class HubClient {\n        remote function notifyContentDistribution(websubhub:ContentDistributionMessage msg) \n                returns ContentDistributionSuccess | SubscriptionDeletedError | error?\n    }\n```\n\n* The following is a sample **WebSub HubClient**.\n\n```ballerina\n    type HubService service object {\n        remote function onSubscriptionIntentVerified(websubhub:Subscription msg) {\n\n            \/\/ you can pass client config if you want \n            \/\/ say maybe retry config\n            websub:HubClient hubclient = new(msg);\n            check start notifySubscriber(hubclient);\n        }\n\n        function notifySubscriber(websubhub:HubClient hubclient) returns error? {\n            while (true) {\n                \/\/ fetch the message from MB\n                check hubclient->notifyContentDistribution({\n                    content: \"This is sample content delivery\"\n                });\n            }   \n        }\n    }\n```\n\n#### Using Publisher Client\n\n* The `PublisherClient` APIs are defined by Ballerina and it has no connection with the WebSub specification. As mentioned earlier, even though the\nWebSub specification extensively discusses the relationship between the subscriber and hub, it does not discuss much the relationship between the publisher and hub.\n\n* The following is a sample **WebSub Publisher Client**.\n\n```ballerina\n    websubhub:PublisherClient publisherClient = new (\"http:\/\/localhost:9191\/websub\/hub\");\n\n    check publisherClient->registerTopic(\"http:\/\/websubpubtopic.com\");\n   \n    var publishResponse = publisherClient->publishUpdate(\n                \"http:\/\/websubpubtopic.com\",\n                {\n                    \"action\": \"publish\", \n                    \"mode\": \"remote-hub\"\n                });\n```\n\n# Returning Errors from Remote Methods\n\n* Remote functions in `websubhub:Service` can return `error` type.\n```ballerina\nservice \/websubhub on new websubhub:Listener(9090) {\n\n    isolated remote function onRegisterTopic(websubhub:TopicRegistration message)\n                                returns websubhub:TopicRegistrationSuccess|websubhub:TopicRegistrationError|error {\n        boolean validationSuccessfull = check validateRegistration(message);\n        if (validationSuccessfull) {\n            websubhub:TOPIC_REGISTRATION_SUCCESS;\n        } else {\n            return websubhub:TOPIC_REGISTRATION_ERROR;\n        }\n    }\n\n    \/\/ implement other remote methods\n}\n\nfunction validateRegistration(websubhub:TopicRegistration message) returns boolean|error {\n   \/\/ implement validation\n}\n```\n\n* For each remote method `error` return has a different meaning. Following table depicts the meaning inferred from `error` returned from all available remote methods.\n\n| Method        | Interpreted meaning for Error Return |\n| ----------- | ---------------- |\n| onRegisterTopic | Topic registration failure |\n| onDeregisterTopic | Topic de-registration failure |\n| onUpdateMessage | Update message error |\n| onSubscription | Subscription internal server error |\n| onSubscriptionValidation | Subscription validation failure |\n| onSubscriptionIntentVerified | Subscription intent verification failure |\n| onUnsubscription | Unsubscription internal server error |\n| onUnsubscriptionValidation | Unsubscription validation failure |\n| onUnsubscriptionIntentVerified | Unsubscription intent verification failure |", "apiDocURL":"https://docs.central.ballerina.io/ballerina/websubhub/0.2.0-beta.1", "packageUrl":"/ballerina/websubhub/0.2.0-beta.1"}], "pullCount":4}, {"organization":"ballerina", "name":"graphql", "version":"0.2.0-beta.1", "platform":"java11", "languageSpecificationVersion":"2021R1", "URL":"/ballerina/graphql/0.2.0-beta.1", "balaVersion":"2.0.0", "balaURL":"https://fileserver.central.ballerina.io/2.0/ballerina/graphql/0.2.0-beta.1/ballerina-graphql-java11-0.2.0-beta.1.bala", "digest":"sha-256=92a0b4ddcf61fb62922a941d8c7c79484cf47eba8c6fef3484d3ca7bc45d59eb", "summary":"", "readme":"# Package Overview\n\nThe `graphql` library is one of the standard library packages of the<a target=\"_blank\" href=\"https:\/\/ballerina.io\/\"> Ballerina <\/a> language.\n\nThis package provides support for implementing a GraphQL service using Ballerina. GraphQL is a data query and manipulation language for APIs. \nUnlike the REST APIs, GraphQL provides a way for clients to request exactly what they want and the GraphQL server only sends the requested data by defining a structure of the data, which will prevent from returning excessively larger amounts of data. \n\n### Report Issues\nTo report bugs, request new features, start new discussions, view project boards, etc., go to the [Ballerina Standard Library parent repository](https:\/\/github.com\/ballerina-platform\/ballerina-standard-library).\n\n### Useful Links\n- Discuss code changes of the Ballerina project in [ballerina-dev@googlegroups.com](mailto:ballerina-dev@googlegroups.com).\n- Chat live with us via our [Slack channel](https:\/\/ballerina.io\/community\/slack\/).\n- Post all technical questions on Stack Overflow with the [#ballerina](https:\/\/stackoverflow.com\/questions\/tagged\/ballerina) tag.", "template":false, "licenses":[], "authors":[], "sourceCodeLocation":"", "keywords":[], "ballerinaVersion":"slbeta1", "icon":"", "createdDate":1622631097000, "modules":[{"name":"graphql", "summary":"", "readme":"## Overview\n\nThis module provides APIs for connecting and interacting with GraphQL endpoints.\n\nGraphQL is an open-source data query and manipulation language for APIs. GraphQL allows clients to define the structure of the data required and the same structure of the data is returned from the server preventing the returning of excessively large amounts of data.\n\nThe Ballerina GraphQL implementation is using HTTP as the underlying protocol.\n\n### Listener\n\nThe `graphql:Listener` is used to listen to a given IP\/Port. To create a `graphql:Listener`, an `http:Listener` or a port number can be used.\n\n#### Create a Standalone `graphql:Listener`\n```ballerina\nimport ballerina\/graphql;\n\nlistener graphql:Listener graphqlListener = new(4000);\n```\n\n#### Create a `graphql:Listener` Using an `http:Listener`\n```ballerina\nimport ballerina\/graphql;\nimport ballerina\/http;\n\nlistener http:Listener httpListener = check new(4000);\nlistener graphql:Listener graphqlListener = new(httpListener);\n```\n\n#### Additional Configurations\nWhen initializing the Ballerina GraphQL listener, a set of additional configurations can be provided to configure the listener including security and resiliency settings.\nThe configurations that can be passed for this are defined in the `graphql:ListenerConfiguration` record.\n\n```ballerina\nimport ballrina\/graphql;\n\nlistener graphql:Listener graphqlListener = new (4000, timeout = 10, secureSocket = { key: { path: <KEYSTORE_PATH>, password: <PASSWORD>}});\n```\n\n### Service\nThe Ballerina GraphQL service represents the GraphQL schema. When a service is attached to a `graphql:Listener`, a GraphQL schema will be auto-generated. The resource functions inside the service represent the resolvers of the root type.\nThen, the GraphQL listener will handle all the incoming requests and dispatch them to the relevant resource function.\n\nSince the GraphQL endpoints are exposed through a single endpoint, the endpoint URL of the GraphQL service can be provided after the service declaration as shown in the following code snippet in which the endpoint URL is `\/graphql`.\n\nThe accessor of the resource function should always be `get`. The resource function name will become the name of the particular field in the GraphQL schema. The return type of the resource function will be the type of the corresponding field.\n\n```ballerina\nimport ballerina\/graphql;\n\nservice graphql:Service \/graphql on new graphql:Listener(4000) {\n    resource function get greeting(string name) returns string {\n        return \"Hello, \" + name;\n    }\n}\n```\n\nThe above can be queried using the GraphQL document below:\n\n```\n{\n    greeting(name: \"John\")\n}\n```\n\nThe result will be the following JSON.\n\n```json\n{\n    \"data\": {\n        \"greeting\": \"Hello, John\"\n    }\n}\n```\n\n\n#### Additional Configurations\nAdditional configurations of a Ballerina GraphQL service can be provided using the `graphql:ServiceConfig`.\nThese configurations include security-related configurations for the GraphQL service.\n\n##### Security Configurations\nA GraphQL service\n```ballerina\n@graphql:SeviceConfig {\n    auth: [\n        {\n            oauth2IntrospectionConfig: {\n                url: <auth_introspection_url>,\n                tokenTypeHint: <access_token>,\n                scopeKey: <scope_key>,\n                clientConfig: {\n                    secureSocket: {\n                       cert: {\n                           path: <truststore_path>,\n                           password: <password>\n                       }\n                    }\n                }\n            },\n            scopes: [<comma_separated_list_of_scopes>]\n        }\n    ]\n}\nservice graphql:Service \/graphql on new graphql:Listener(4000) {\n    \/\/ Service definition\n}\n```\n\n##### Maximum Query Depth\nWhen a maximum query depth is provided, all the queries exceeding that limit will be rejected at the validation phase and will not be executed.\n\n```ballerina\nimport ballerina\/graphql;\n\n@graphql:ServiceConfig {\n    maxQueryDepth: 2\n}\nservice graphql:Service \/graphql on new graphql:Listener(9090) {\n    \/\/ Service definition\n}\n```\n\nThe above service only accepts queries of less than 2 levels. For an example, consider the following document:\n```\nquery getData {\n    book {\n        author {\n            books {\n                author {\n                    books\n                }\n            }\n        }\n    }\n}\n```\n\nThe result for the above query is the following JSON:\n\n```json\n{\n    \"errors\": [\n        {\n            \"message\": \"Query \\\"getData\\\" has depth of 5, which exceeds max depth of 2\",\n            \"locations\": [\n                {\n                    \"line\": 1,\n                    \"column\": 1\n                }\n            ]\n        }\n    ]\n}\n```\n\n### Types\nThe Ballerina GraphQL resources can return the following types:\n\n#### Return Types\n\n##### Scalar types\nThe following Ballerina types are considered as Scalar types:\n- `int`\n- `string`\n- `boolean`\n- `float`\n- `decimal`\n- `enum`\n\n```ballerina\nresource function get greeting() returns string {\n    return \"Hello, World\";\n}\n```\n\nThis can be queried using the following document:\n```\n{\n    greeting\n}\n```\n\nResult:\n```json\n{\n    \"data\": {\n        \"greeting\": \"Hello, World\"\n    }\n}\n```\n\n##### Record types\n\nWhen a resource is returning a record type, each field of the record can be queried separately.\nEach record type is mapped to a GraphQL `OBJECT` type and the fields of the record type are mapped to the fields of the `OBJECT` type.\n\n```ballerina\npublic type Person record {|\n    string name;\n    int age;\n|};\n\nresource function get profile() returns Person {\n    return { name: \"Walter White\", age: 51 };\n}\n```\n\nThis will generate the following schema.\n```\ntype Query {\n    profile: Person!\n}\n\ntype Person {\n    name: String!\n    age: Int!\n}\n```\n\nThis can be queried using the following document:\n```\n{\n    profile {\n        name\n        age\n    }\n}\n```\n\nResult:\n```json\n{\n    \"data\": {\n        \"profile\": {\n            \"name\": \"Walter White\",\n            \"age\": 51\n        }\n    }\n}\n```\n\nEach field can be queried separately as shown in the following document:\n```\n{\n    profile {\n        name\n    }\n}\n```\n\nResult:\n```json\n{\n    \"data\": {\n        \"profile\": {\n            \"name\": \"Walter White\"\n        }\n    }\n}\n```\n\n#### Service Objects\nWhen a resource function returns a service object, the service type is mapped to a GraphQL `OBJECT` type and the resource functions of the service type will be mapped as the fields of the `OBJECT`.\n\nWhen a service type is returned from a `graphql:Service`, the returning service type should also follow the rules of the `graphql:Service` explained above.\n\n```ballerina\nimport ballerina\/graphql;\n\nservice graphql:Service \/graphql on new graphql:Listener(4000) {\n    resource function get profile() returns Person {\n        return new(\"Walter White\", 51);\n    }\n}\n\nservice class Person {\n    private string name;\n    private int age;\n    \n    public function init(string name, int age) {\n        self.name = name;\n        self.age = age;\n    }\n    \n    resource function get name() returns string {\n        return self.name;\n    }\n    \n    resource function get age() returns int {\n        return self.age;\n    }\n}\n```\n\nThis will generate the following schema:\n\n```\ntype Query {\n    profile: Person!\n}\n\ntype Person {\n    name: String!\n    age: Int!\n}\n```\n\nThis can be queried using the following document:\n\n```graphql\nquery getProfile {\n    profile {\n        name\n    }\n}\n```\n\nThe above will result in the following JSON:\n\n```json\n{\n    \"data\": {\n        \"profile\": {\n            \"name\": \"Walter White\"\n        }\n    }\n}\n```\n\n#### Arrays\nA GraphQL resource can return an array of the types mentioned above.\nWhen a resource is returning an array, the result will be a JSON array.\n\n```ballerina\npublic type Person record {|\n    string name;\n    int age;\n|};\n\nresource function get people() returns Person[] {\n    Person p1 = { name: \"Walter White\", age: 51 };\n    Person p2 = { name: \"James Moriarty\", age: 45 };\n    Person p3 = { name: \"Tom Marvolo Riddle\", age: 71 };\n    return [p1, p2, p3];\n}\n```\n\nThis will generate the following schema:\n\n```\ntype Query {\n    profile: [Person!]!\n}\n\ntype Person {\n    name: String!\n    age: Int!\n}\n```\n\nThis can be queried using the following document:\n```\n{\n    people {\n        name\n    }\n}\n```\n\nResult:\n```json\n{\n    \"data\": {\n        \"people\": [\n            {\n                \"name\": \"Walter White\"\n            },\n            {\n                \"name\": \"James Moriarty\"\n            },\n            {\n                \"name\": \"Tom Marvolo Riddle\"\n            }\n        ]\n    }\n}\n```\n\nNote: Each element in the array consists only of the required `name` field.\n\n\n#### Optional Types\nA Ballerina GraphQL resource can return an optional type. When the return value is `()`, the resulting field in the JSON will be `null`.\n\n```ballerina\npublic type Person record {|\n    string name;\n    int age;\n|};\n\nresource function get profile(int id) returns Person? {\n    if (id == 1) {\n        return { name: \"Walter White\", age: 51 };\n    }\n}\n```\n\nThis will generate the following schema:\n\n```\ntype Query {\n    profile: Person\n}\n\ntype Person {\n    name: String!\n    age: Int!\n}\n```\n\nThis can be queried using the following document:\n```\n{\n    profile(id: 1) {\n        name\n    }\n}\n```\n\nResult:\n```json\n{\n    \"data\": {\n        \"profile\": {\n            \"name\": \"Walter White\"\n        }\n    }\n}\n```  \n\nIf the following document is used:\n```\n{\n    profile(id: 4) {\n        name\n    }\n}\n```\n\nThis will be the result:\n```json\n{\n    \"data\": {\n        \"profile\": null\n    }\n}\n``` \n\n#### Union Types\nThe Ballerina GraphQL service can return a union of distinct service types. This will be mapped to a GraphQL `UNION` type.\n\nSince Ballerina supports the union types by nature, directly returning a union type is also allowed (but not recommended). The recommended way is to define a union type name separately and then use that type name as shown in the following example. If a union type is returned directly without providing a type name, the type name will be `T1|T2|T3|...|Tn`.\n\n```ballerina\nimport ballerina\/graphql;\n\npublic type StudentOrTeacher Student|Teacher;\n\nservice \/graphql on new graphql:Listener(4000) {\n    resource function get profile(int purity) returns StudentOrTeacher {\n        if (purity < 90) {\n            return new Student(1, \"Jesse Pinkman\");\n        } else {\n            return new Teacher(737, \"Walter White\", \"Chemistry\");\n        }\n    }\n}\n\ndistinct service class Student {\n    private int id;\n    private string name;\n    \n    public function init(int id, string name) {\n        self.id = id;\n        self.name = name;\n    }\n    \n    resource function get id() returns int {\n        return self.id;\n    }\n    \n    resource function get name() returns string {\n        return self.name;\n    }\n}\n\ndistinct service class Teacher {\n    private int id;\n    private string name;\n    private string subject;\n    \n    public function init(int id, string name, string subject) {\n        self.id = id;\n        self.name = name;\n        self.subject = subject;\n    }\n    \n    resource function get id() returns int {\n        return self.id;\n    }\n    \n    resource function get name() returns string {\n        return self.name;\n    }\n        \n    resource function get subject() returns string {\n        return self.subject;\n    }\n}\n```\n\nThis will generate the following schema: \n\n```\ntype Query {\n    profile(purity: Int!): StudentOrTeacher!\n}\n\ntype Student {\n    id: Int!\n    name: String!\n}\n\ntype Teacher {\n    id: Int!\n    name: String!\n    subject: String!\n}\n\nunion StudentOrTeacher Student|Teacher\n```\n\nThis can be queried using the following document:\n\n```\nquery {\n    profile(purity: 75) {\n        ... on Student {\n            name\n        }\n        ... on Teacher {\n            name\n            subject\n        }\n    }\n}\n```\n\nThe result will be:\n\n```json\n{\n    \"data\": {\n        \"profile\": {\n            \"name\": \"Jesse Pinkman\"\n        }\n    }\n}\n``` \n\nIf the following document is used:\n\n```\nquery {\n    profile(purity: 99) {\n        ... on Student {\n            name\n        }\n        ... on Teacher {\n            name\n            subject\n        }\n    }\n}\n```\n\nThe result will be:\n\n```json\n{\n    \"data\": {\n        \"profile\": {\n            \"name\": \"Walter White\",\n            \"subject\": \"Chemistry\"\n        }\n    }\n}\n``` \n\n#### Errors (With union)\nA Ballerina GraphQL resource can return an `error` with the union of the types mentioned above.\n\nNote: A resource cannot return an `error`, any subtype of an `error`, or, an `error?`, which will result in a compilation error.\n\n```ballerina\npublic type Person record {|\n    string name;\n    int age;\n|};\n\nresource function get profile(int id) returns Person|error {\n    if (id == 1) {\n        return { name: \"Walter White\", age: 51 };\n    } else {\n        return error(string `Invalid ID provided: ${id}`);\n    }\n}\n```\n\nThis can be queried using the following document:\n```\n{\n    profile(id: 5) {\n        name\n    }\n}\n```\n\nResult:\n```json\n{\n    \"errors\": [\n        {\n            \"message\": \"Invalid ID provided: 5\",\n            \"locations\": [\n                {\n                    \"line\": 2,\n                    \"column\": 4\n                }\n            ]\n        }\n    ]\n}\n```\n\n#### Hierarchical Resource Paths\nA resource inside a GraphQL service can have hierarchical paths.\nWhen a hierarchical path is present, each level of the hierarchical path maps to the GraphQL field of the same name, and the type of that field will be mapped to an `OBJECT` type with the same name.\n\n```ballerina\nimport ballerina\/graphql;\n\nservice graphql:Service \/graphql on new graphq:Listener(4000) {\n    resource function profile\/name\/first() returns string {\n        return \"Walter\";\n    }\n    \n    resource function profile\/name\/last() returns string {\n        return \"White\"\n    }\n    \n    resource function profile\/age() returns int {\n        return 51;\n    }\n}\n```\n\nThe above service will create the following schema:\n\n```graphql\ntype Query {\n    profile: profile!\n}\n\ntype profile {\n    name: name!\n    age: Int!\n}\n\ntype name {\n    first: String!\n    last: String!\n}\n```\n\nNote: The field name, and the type names are equal.", "apiDocURL":"https://docs.central.ballerina.io/ballerina/graphql/0.2.0-beta.1", "packageUrl":"/ballerina/graphql/0.2.0-beta.1"}], "pullCount":3}], "count":106, "offset":0, "limit":15}